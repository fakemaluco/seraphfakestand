<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seraph's Last Stand</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=VT323&display=swap" rel="stylesheet">

    <style>
        @keyframes pulse-title { 0%, 100% { transform: scale(1); text-shadow: 4px 4px 0 #5a4a00, 0 0 30px rgba(255, 199, 0, 0.3); } 50% { transform: scale(1.05); text-shadow: 6px 6px 5px #5a4a00, 0 0 50px rgba(255, 199, 0, 0.6); } }
        @keyframes pulse-red { 0%, 100% { transform: scale(1); text-shadow: 2px 2px 0 #330000; } 50% { transform: scale(1.02); text-shadow: 3px 3px 3px #550000; } }
        @keyframes screen-shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-3px, 3px); } 50% { transform: translate(3px, -3px); } 75% { transform: translate(-3px, -3px); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }

        :root { --border-color: #FFF; --text-color: #FFF; --bg-color: #000; --dark-bg-color: #111; --accent-color: #e6b800; --border-radius: 0px; }

        body { background-color: var(--dark-bg-color); color: var(--text-color); font-family: 'VT323', monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; transition: background-image 0.5s ease; }
        #gameContainer { position: relative; width: 100%; max-width: 1280px; aspect-ratio: 16 / 9; background-color: #000; border: 4px solid var(--border-color); box-sizing: border-box; transition: transform 0.1s, border-radius 0.5s ease; border-radius: var(--border-radius); overflow: hidden; }
        #gameContainer.shake { animation: screen-shake 0.1s linear 1; }
        #gameCanvas { width: 100%; height: 100%; image-rendering: pixelated; position: absolute; top: 0; left: 0; z-index: 1; border-radius: var(--border-radius); cursor: url('cursor.png') 0 0, auto; }
        
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.8); transition: opacity 0.5s ease, backdrop-filter 0.5s ease; z-index: 10; text-align: center; border-radius: var(--border-radius); }
        .overlay.hidden { opacity: 0; pointer-events: none; }
        
        #preloader { z-index: 99; background-color: #000; cursor: pointer;}
        #preloader h1 { font-family: 'VT323', monospace; font-size: 3rem; color: #fff; animation: pulse-title 3s ease-in-out infinite; }

        #startScreen { background: radial-gradient(circle at 50% 50%, #1a1a1a, #000); }
        #startScreen h1 { font-family: 'Cinzel', serif; font-size: clamp(3rem, 10vw, 6rem); line-height: 1.1; margin: 0; color: var(--accent-color); animation: pulse-title 5s ease-in-out infinite; }
        .start-button { font-family: 'VT323', monospace; background: none; color: var(--text-color); cursor: pointer; border: 4px solid var(--border-color); box-shadow: 0 0 0 2px var(--bg-color), 0 0 0 4px var(--border-color); background-color: var(--bg-color); padding: 15px 50px; font-size: 2.5rem; transition: all 0.3s ease; border-radius: var(--border-radius); }
        .start-button:hover:not(:disabled) { color: var(--accent-color); border-color: var(--accent-color); box-shadow: 0 0 0 2px var(--bg-color), 0 0 0 4px var(--accent-color), 0 0 20px var(--accent-color); transform: scale(1.05); }
        .start-button:disabled { color: #666; border-color: #666; cursor: not-allowed; }
        .main-menu-buttons { display: flex; flex-direction: column; gap: 10px; margin-top: 2rem;}
        .main-menu-buttons .start-button { animation: float 3s ease-in-out infinite; }
        .main-menu-buttons .start-button:nth-child(2) { animation-delay: 0.2s; }
        .main-menu-buttons .start-button:nth-child(3) { animation-delay: 0.4s; }
        .main-menu-buttons .start-button:nth-child(4) { animation-delay: 0.6s; }

        .overlay-menu-button { margin: 10px; width: 250px; }
        
        /* Character Selection */
        #characterSelection { display: flex; gap: 2rem; margin: 1.5rem 0; }
        .char-card { border: 4px solid #555; padding: 1rem; cursor: pointer; transition: all 0.3s ease; text-align: center; }
        .char-card:hover { border-color: var(--text-color); transform: scale(1.05); }
        .char-card.selected { border-color: var(--accent-color); box-shadow: 0 0 15px var(--accent-color); transform: scale(1.1); }
        .char-card h4 { font-family: 'Cinzel', serif; margin: 10px 0 0 0; font-size: 1.2rem; }
        .char-preview { width: 64px; height: 128px; image-rendering: pixelated; background-color: #333; margin: 0 auto; display: flex; justify-content: center; align-items: center; font-size: 3rem; }
        .char-preview img { width: 100%; height: 100%; }

        #gameOverScreen { background-color: rgba(30, 0, 0, 0.8); }
        #gameOverScreen h2 { font-family: 'Cinzel', serif; font-size: 6rem; color: #d44; margin: 0; animation: pulse-red 2s ease-in-out infinite; }
        #gameOverScreen p { font-size: 2.5rem; margin: 20px 0; }
        #highScoreText { color: var(--accent-color); font-size: 1.8rem; }
        #retryButton { font-family: 'VT323', monospace; font-size: 2rem; color: #ccc; border: 4px solid #ccc; background-color: #222; padding: 10px 40px; cursor: pointer; transition: all 0.2s ease; border-radius: var(--border-radius); }
        #retryButton:hover { color: #fff; border-color: #fff; background-color: #444; transform: scale(1.05); }
        
        #hud { position: absolute; top: 20px; left: 20px; z-index: 5; width: 30%; max-width: 350px; font-size: 1.2rem; display: flex; flex-direction: column; gap: 5px;}
        .hud-item { display: flex; align-items: center; gap: 10px; }
        .bar-container { flex-grow: 1; height: 20px; background-color: rgba(0, 0, 0, 0.4); border: 2px solid #fff; box-sizing: border-box; border-radius: var(--border-radius); overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.3s ease-out; }
        #hp-bar { background-color: #c0392b; } #exp-bar { background-color: #2980b9; }

        #pauseScreen .pause-content { display: flex; justify-content: space-around; width: 80%; max-width: 900px; margin-top: 1rem; align-items: flex-start; }
        .pause-column { background-color: rgba(0,0,0,0.5); border: 2px solid #555; padding: 1.5rem; width: 45%; border-radius: var(--border-radius); }
        .pause-column h3 { font-family: 'Cinzel', serif; font-size: 1.8rem; margin-top: 0; margin-bottom: 1rem; color: var(--accent-color); text-shadow: 2px 2px #333; }
        #pauseStats p { font-size: 1.1rem; margin: 5px 0; text-align: left; }
        #pauseUpgrades .upgrade-item { font-size: 1rem; padding: 5px 10px; margin-bottom: 5px; border-left: 5px solid; text-align: left; }
        .upgrade-item.common { border-color: #ccc; color: #ccc; } .upgrade-item.uncommon { border-color: #55ff55; color: #55ff55; } .upgrade-item.rare { border-color: #8855ff; color: #8855ff; }

        #levelUpScreen { backdrop-filter: blur(5px); }
        #levelUpScreen h2 { font-family: 'Cinzel', serif; font-size: 3rem; margin-bottom: 2rem; color: #fff; text-shadow: 3px 3px #333; }
        .card-container { display: flex; gap: 20px; perspective: 1200px; margin-bottom: 2rem; }
        #rerollButton { font-size: 1.5rem; padding: 10px 30px; }

        .card { width: 170px; height: 250px; background-color: #000; border: 3px solid #444; cursor: pointer; position: relative; padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.6s ease, border-color 0.4s ease; transform-style: preserve-3d; border-radius: var(--border-radius); }
        .card-title { font-family: 'Cinzel', serif; margin: 0 0 10px 0; font-size: 1.1rem; color: #fff; }
        .card.common .card-title { color: #fff; } .card.uncommon .card-title { color: #55ff55; } .card.rare .card-title { color: #8855ff; }
        .card-icon { width: 90px; height: 90px; border: 3px solid #ccc; margin-bottom: 15px; display: flex; justify-content: center; align-items: center; background-color: #111; font-size: 3rem; color: white; border-radius: var(--border-radius); }
        .card-description { color: #ddd; text-align: center; font-size: 0.9rem; line-height: 1.3; }
        .card.hover-focus { transform: translateY(-25px) scale(1.1); border-color: #66ff66; z-index: 101; }
        .card.look-left { transform: rotateY(-20deg) scale(0.95); } .card.look-right { transform: rotateY(20deg) scale(0.95); }
        .card.selected { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1.25); border-color: #ffa500; z-index: 100; }
        .card.exploding { opacity: 0; pointer-events: none; }
        .card.exploding:nth-of-type(odd) { transform: translate(-60vw, -110vh) rotate(-480deg) scale(0); }
        .card.exploding:nth-of-type(even) { transform: translate(60vw, 110vh) rotate(480deg) scale(0); }
        .card.exploding:nth-of-type(3n) { transform: translate(0, 120vh) rotate(360deg) scale(0); }
        .card.selected.exit-down { transition-timing-function: cubic-bezier(0.16, 1, 0.3, 1); transform: translate(-50%, 150vh) scale(1.25); }

        #settingsScreen .settings-container, #achievementsScreen .achievements-container, #creditsScreen .settings-container { display: flex; flex-direction: column; gap: 1.5rem; background: rgba(0,0,0,0.6); border: 2px solid #555; padding: 2rem; width: 60%; max-width: 600px; border-radius: var(--border-radius); }
        .setting-item { display: flex; justify-content: space-between; align-items: center; font-size: 1.5rem; }
        .setting-item input[type="range"], .setting-item input[type="number"] { width: 50%; }
        .setting-item input[type="checkbox"] { width: 25px; height: 25px; cursor: pointer; }
        .setting-item button { font-size: 1.2rem; padding: 8px 15px; width: 50%; }

        #achievementsScreen .achievements-container { max-height: 70vh; overflow-y: auto; }
        .achievement-item { display: flex; align-items: center; padding: 10px; background-color: #222; margin-bottom: 10px; border-left: 5px solid #555; transition: all 0.3s ease; border-radius: var(--border-radius); }
        .achievement-item.unlocked { background-color: #4a4a2a; border-left-color: var(--accent-color); }
        .achievement-icon { font-size: 2.5rem; width: 50px; text-align: center; margin-right: 15px; }
        .achievement-details { text-align: left; }
        .achievement-details h4 { margin: 0; font-size: 1.2rem; }
        .achievement-details p { margin: 0; font-size: 1rem; color: #aaa; }
        .achievement-item.unlocked .achievement-details h4 { color: var(--accent-color); }
        .achievement-item.unlocked .achievement-details p { color: #eee; }

        body.frutiger-aero-active { background-image: url('background.png'); background-size: cover; background-position: center; }
        body.frutiger-aero-active { --border-radius: 15px; }

        #debugPanel { flex-direction: column; gap: 1rem; margin-top: 1.5rem; border-top: 2px solid #555; padding-top: 1.5rem; }
        #debugPanel h3 { color: #ff4757; margin: 0 0 1rem 0; font-size: 1.5rem; }
        .hidden { display: none !important; }

    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud"><div class="hud-item"><span id="hpText">HP: 100/100</span><div class="bar-container"><div id="hp-bar" class="bar-fill"></div></div></div><div class="hud-item"><span id="expText">LVL: 1</span><div class="bar-container"><div id="exp-bar" class="bar-fill"></div></div></div></div>
        <canvas id="gameCanvas"></canvas>
        <div id="preloader" class="overlay"><h1 id="preloaderText">LOADING...</h1></div>
        <div id="startScreen" class="overlay hidden">
            <h1>SERAPH'S<br>LAST STAND</h1>
            <p>CHOOSE YOUR HERO</p>
            <div id="characterSelection">
                <div class="char-card" data-char="wizard">
                    <div class="char-preview"><img id="wizardPreview" alt="Wizard Character"></div>
                    <h4>Seraph (Mage)</h4>
                </div>
                <div class="char-card" data-char="gladiator">
                    <div class="char-preview" style="background-color: #6c757d;">G</div>
                    <h4>Gladiator</h4>
                </div>
            </div>
            <div class="main-menu-buttons">
                <button id="startButton" class="start-button" disabled>START</button>
                <button id="achievementsButtonMain" class="start-button overlay-menu-button" style="font-size: 1.5rem; padding: 10px 30px;">Achievements</button>
                <button id="settingsButtonMain" class="start-button overlay-menu-button" style="font-size: 1.5rem; padding: 10px 30px;">Settings</button>
                <button id="creditsButton" class="start-button overlay-menu-button" style="font-size: 1.5rem; padding: 10px 30px;">Credits</button>
            </div>
        </div>
        <div id="pauseScreen" class="overlay hidden">
            <h1>PAUSED</h1><div class="pause-content"><div class="pause-column" id="pauseStats"><h3>Player Stats</h3></div><div class="pause-column" id="pauseUpgrades"><h3>Current Upgrades</h3></div></div>
            <button id="continueButton" class="start-button overlay-menu-button">Continue</button><button id="settingsButtonPause" class="start-button overlay-menu-button" style="font-size: 1.5rem; padding: 10px 30px;">Settings</button><button id="newGameButton" class="start-button overlay-menu-button">New Game</button>
        </div>
        <div id="levelUpScreen" class="overlay hidden"><h2>Choose a Card</h2><div class="card-container"></div><button id="rerollButton" class="start-button">Reroll</button></div>
        <div id="gameOverScreen" class="overlay hidden"><h2>GAME OVER</h2><p id="scoreText">Score: 0</p><p id="highScoreText">High Score: 0</p><button id="retryButton">Retry</button></div>
        <div id="settingsScreen" class="overlay hidden">
            <h1>Settings</h1><div class="settings-container"><div class="setting-item"><label for="musicVolume">Music Volume</label><input type="range" id="musicVolume" min="0" max="1" step="0.05"></div><div class="setting-item"><label for="sfxVolume">SFX Volume</label><input type="range" id="sfxVolume" min="0" max="1" step="0.05"></div><div class="setting-item"><label for="cameraSmoothingCheckbox">Smooth Camera</label><input type="checkbox" id="cameraSmoothingCheckbox"></div><div class="setting-item"><label for="showDamageNumbersCheckbox">Show Damage</label><input type="checkbox" id="showDamageNumbersCheckbox"></div><div class="setting-item"><label for="bloomEffectCheckbox">Bloom Effect</label><input type="checkbox" id="bloomEffectCheckbox"></div><div class="setting-item"><label for="frutigerAeroCheckbox">Frutiger Aero</label><input type="checkbox" id="frutigerAeroCheckbox"></div><div class="setting-item"><label for="fullscreenBtn">Fullscreen</label><button id="fullscreenBtn" class="start-button">Enter</button></div>
            <div id="debugPanel" class="hidden">
                <h3>- DEBUG PANEL -</h3>
                <div class="setting-item"><label for="debugLevel">Player Level</label><input type="number" id="debugLevel" min="1" max="99"></div>
                <div class="setting-item"><label for="debugDamage">Base Damage</label><input type="number" id="debugDamage" min="1" max="500"></div>
                <div class="setting-item"><label for="debugMaxHp">Max HP</label><input type="number" id="debugMaxHp" min="10" max="1000"></div>
                <div class="setting-item"><button id="godModeBtn" class="start-button">God Mode (OFF)</button></div>
            </div>
            </div>
            <button id="closeSettingsButton" class="start-button overlay-menu-button" style="margin-top: 2rem;">Back</button>
        </div>
        <div id="achievementsScreen" class="overlay hidden">
            <h1>Achievements</h1><div class="achievements-container"></div>
            <button id="closeAchievementsButton" class="start-button overlay-menu-button" style="margin-top: 2rem;">Back</button>
        </div>
        <div id="creditsScreen" class="overlay hidden">
            <h1>Credits</h1>
            <div class="settings-container" style="text-align: center; font-size: 1.2rem; line-height: 1.6;">
                <p>A Game By: You!</p>
                <p>Inspired by Vampire Survivors & other great games.</p>
                <p>Assets from various open-source creators.</p>
                <p>Font 'Cinzel' & 'VT323' from Google Fonts.</p>
                <br>
                <p style="color: var(--accent-color);">Special thanks to the developer who implemented this feature map!</p>
            </div>
            <button id="closeCreditsButton" class="start-button overlay-menu-button" style="margin-top: 2rem;">Back</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const elements = { gameContainer: document.getElementById('gameContainer'), canvas: document.getElementById('gameCanvas'), preloader: document.getElementById('preloader'), preloaderText: document.getElementById('preloaderText'), startScreen: document.getElementById('startScreen'), startButton: document.getElementById('startButton'), pauseScreen: document.getElementById('pauseScreen'), continueButton: document.getElementById('continueButton'), newGameButton: document.getElementById('newGameButton'), levelUpScreen: document.getElementById('levelUpScreen'), gameOverScreen: document.getElementById('gameOverScreen'), retryButton: document.getElementById('retryButton'), scoreText: document.getElementById('scoreText'), highScoreText: document.getElementById('highScoreText'), hpBar: document.getElementById('hp-bar'), expBar: document.getElementById('exp-bar'), hpText: document.getElementById('hpText'), expText: document.getElementById('expText'), rerollButton: document.getElementById('rerollButton'), settingsScreen: document.getElementById('settingsScreen'), settingsButtonMain: document.getElementById('settingsButtonMain'), settingsButtonPause: document.getElementById('settingsButtonPause'), closeSettingsButton: document.getElementById('closeSettingsButton'), musicVolumeSlider: document.getElementById('musicVolume'), sfxVolumeSlider: document.getElementById('sfxVolume'), cameraSmoothingCheckbox: document.getElementById('cameraSmoothingCheckbox'), showDamageNumbersCheckbox: document.getElementById('showDamageNumbersCheckbox'), bloomEffectCheckbox: document.getElementById('bloomEffectCheckbox'), frutigerAeroCheckbox: document.getElementById('frutigerAeroCheckbox'), achievementsScreen: document.getElementById('achievementsScreen'), achievementsButtonMain: document.getElementById('achievementsButtonMain'), closeAchievementsButton: document.getElementById('closeAchievementsButton'), creditsScreen: document.getElementById('creditsScreen'), creditsButton: document.getElementById('creditsButton'), closeCreditsButton: document.getElementById('closeCreditsButton'), fullscreenBtn: document.getElementById('fullscreenBtn'), debugPanel: document.getElementById('debugPanel'), debugLevel: document.getElementById('debugLevel'), debugDamage: document.getElementById('debugDamage'), debugMaxHp: document.getElementById('debugMaxHp'), godModeBtn: document.getElementById('godModeBtn'), wizardPreview: document.getElementById('wizardPreview'), characterSelection: document.getElementById('characterSelection') };
            const ctx = elements.canvas.getContext('2d'); let animationFrameId; let game; let globalAudioManager; let debugUnlocked = false; let selectedCharacter = null;

            class SettingsManager { constructor() { this.defaults = { musicVolume: 0.3, sfxVolume: 0.5, cameraSmoothing: true, showDamageNumbers: true, bloom: true, frutigerAero: false, highScore: 0, totalKills: 0, totalDeaths: 0, unlockedAchievements: [] }; this.settings = this.load(); } load() { const saved = localStorage.getItem('seraphsLastStandSettings'); return saved ? { ...this.defaults, ...JSON.parse(saved) } : this.defaults; } save() { localStorage.setItem('seraphsLastStandSettings', JSON.stringify(this.settings)); } get(key) { return this.settings[key]; } set(key, value) { this.settings[key] = value; this.save(); } }
            const settings = new SettingsManager();
            
            const achievements = { 'kill_10': { name: 'Novice Slayer', description: 'Defeat 10 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 10 }, 'kill_50': { name: 'Adept Slayer', description: 'Defeat 50 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 50 }, 'kill_100': { name: 'Expert Slayer', description: 'Defeat 100 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 100 }, 'kill_250': { name: 'Master Slayer', description: 'Defeat 250 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 250 }, 'death_1': { name: 'First of Many', description: 'Die for the first time.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 1 }, 'death_5': { name: 'Getting Used To It', description: 'Die 5 times.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 5 }, 'death_10': { name: 'Persistent', description: 'Die 10 times.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 10 }, 'death_100': { name: 'Why Are We Still Here?', description: 'Die 100 times.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 100 }, 'rare_card': { name: 'A Rare Find', description: 'Obtain a Rare upgrade.', icon: 'üíé', check: (g) => g.player.collectedUpgrades.some(id => upgrades[id]?.rarity === 'rare') }, 'frutiger_aero': { name: 'Sonho do Andrezitos?', description: 'Discover a more... glossy reality.', icon: 'üíß', check: () => settings.get('frutigerAero') } };
            const assetPaths = { images: { player: 'mago.png', gladiator: 'gladiator.png', enemy: 'inimigo.png', eye: 'eye.png', demon: 'demon.png', boss1: 'boss1.png', boss2: 'boss2.png' }, sounds: { soundtrack: 'soundtrack.mp3', menu: 'menu.mp3', bullet: 'bullet.mp3', jump: 'pulo.mp3', playerDamage: 'playerdamage.mp3', playerDeath: 'playerdeathsound.mp3', enemyDeath: 'enemiedeathsound.mp3', cardPickup: 'cardpickup.mp3', click: 'click.mp3', key: 'key.mp3', boss1: 'boss1.mp3', boss2: 'boss2.mp3' } };
            
            class AssetLoader {
                constructor(paths) {
                    this.paths = paths;
                    this.images = {};
                    this.sounds = {};
                }

                load(onProgress) {
                    const imagePromises = Object.entries(this.paths.images).map(([key, path]) => 
                        new Promise((resolve) => {
                            const img = new Image();
                            img.src = path;
                            img.onload = () => {
                                this.images[key] = img;
                                onProgress();
                                resolve();
                            };
                            img.onerror = () => {
                                console.warn(`Could not load image: ${path}`);
                                onProgress();
                                resolve(); // IMPORTANT: Resolve even on error to not block Promise.all
                            };
                        })
                    );

                    const soundPromises = Object.entries(this.paths.sounds).map(([key, path]) =>
                        new Promise((resolve) => {
                            const audio = new Audio();
                            const canPlayHandler = () => {
                                this.sounds[key] = audio;
                                onProgress();
                                audio.removeEventListener('canplaythrough', canPlayHandler);
                                resolve();
                            };
                            audio.addEventListener('canplaythrough', canPlayHandler);
                            audio.onerror = () => {
                                console.warn(`Could not load sound: ${path}`);
                                onProgress();
                                resolve(); // IMPORTANT: Resolve even on error
                            };
                            audio.src = path;
                            audio.load();
                        })
                    );

                    return Promise.all([...imagePromises, ...soundPromises]);
                }
            }
            
            class AudioManager { constructor(sounds) { this.sounds = sounds; this.currentMusic = null; } play(soundName, volumeMultiplier = 1) { if (this.sounds[soundName]) { const sound = this.sounds[soundName].cloneNode(); sound.volume = settings.get('sfxVolume') * volumeMultiplier; sound.play().catch(e => {}); } } startMusic(track) { this.stopAllMusic(); if (this.sounds[track]) { this.currentMusic = this.sounds[track]; this.currentMusic.loop = true; this.currentMusic.volume = settings.get('musicVolume'); this.currentMusic.play().catch(e => {}); } } stopAllMusic() { if(this.currentMusic) { this.currentMusic.pause(); this.currentMusic.currentTime = 0; } this.currentMusic = null; } updateMusicVolume() { if(this.currentMusic) { this.currentMusic.volume = settings.get('musicVolume'); } } }
            
            function resizeCanvas() { const containerRect = elements.gameContainer.getBoundingClientRect(); elements.canvas.width = containerRect.width; elements.canvas.height = containerRect.height; if (game) { game.width = elements.canvas.width; game.height = elements.canvas.height; game.createStars(); } }
            
            const assetLoader = new AssetLoader(assetPaths);
            const totalAssets = Object.keys(assetPaths.images).length + Object.keys(assetPaths.sounds).length; let loadedAssets = 0;
            assetLoader.load(() => { loadedAssets++; elements.preloaderText.textContent = `LOADING... ${Math.round((loadedAssets / totalAssets) * 100)}%`; }).then(() => {
                globalAudioManager = new AudioManager(assetLoader.sounds);
                elements.preloaderText.textContent = "CLICK TO START";
                if(assetLoader.images.player) elements.wizardPreview.src = assetLoader.images.player.src;
                elements.preloader.addEventListener('click', () => {
                    elements.preloader.classList.add('hidden');
                    elements.startScreen.classList.remove('hidden');
                    globalAudioManager.startMusic('menu');
                }, { once: true });
            });

            function setupCharacterSelection() {
                elements.characterSelection.addEventListener('click', (e) => {
                    const card = e.target.closest('.char-card');
                    if (!card) return;
                    selectedCharacter = card.dataset.char;
                    document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    elements.startButton.disabled = false;
                    globalAudioManager.play('click', 0.5);
                });
            }

            function startGame() { if (!selectedCharacter) return; globalAudioManager.play('click'); elements.startScreen.classList.add('hidden'); elements.gameOverScreen.classList.add('hidden'); game = new Game(elements.canvas.width, elements.canvas.height, assetLoader.images, globalAudioManager, selectedCharacter); if(animationFrameId) cancelAnimationFrame(animationFrameId); gameLoop(); }
            function gameLoop(timestamp) { if(game && game.gameState !== 'gameOver') { if (game.gameState === 'playing' || game.gameState === 'bossWave' || game.gameState === 'cutscene') { ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height); game.update(timestamp); game.draw(ctx); } animationFrameId = requestAnimationFrame(gameLoop); } }
            
            function applyFrutigerAero() { document.body.classList.toggle('frutiger-aero-active', settings.get('frutigerAero')); }
            function setupSettingsUI() { elements.musicVolumeSlider.value = settings.get('musicVolume'); elements.sfxVolumeSlider.value = settings.get('sfxVolume'); elements.cameraSmoothingCheckbox.checked = settings.get('cameraSmoothing'); elements.showDamageNumbersCheckbox.checked = settings.get('showDamageNumbers'); elements.bloomEffectCheckbox.checked = settings.get('bloom'); elements.frutigerAeroCheckbox.checked = settings.get('frutigerAero'); const toggleSettings = () => { if(globalAudioManager) globalAudioManager.play('click'); elements.settingsScreen.classList.toggle('hidden'); if(debugUnlocked) elements.debugPanel.classList.remove('hidden');}; elements.settingsButtonMain.addEventListener('click', toggleSettings); elements.settingsButtonPause.addEventListener('click', toggleSettings); elements.closeSettingsButton.addEventListener('click', toggleSettings); elements.musicVolumeSlider.addEventListener('input', (e) => { settings.set('musicVolume', parseFloat(e.target.value)); if(globalAudioManager) globalAudioManager.updateMusicVolume(); }); elements.sfxVolumeSlider.addEventListener('input', (e) => settings.set('sfxVolume', parseFloat(e.target.value))); elements.cameraSmoothingCheckbox.addEventListener('change', (e) => settings.set('cameraSmoothing', e.target.checked)); elements.showDamageNumbersCheckbox.addEventListener('change', (e) => settings.set('showDamageNumbers', e.target.checked)); elements.bloomEffectCheckbox.addEventListener('change', (e) => settings.set('bloom', e.target.checked)); elements.frutigerAeroCheckbox.addEventListener('change', (e) => { settings.set('frutigerAero', e.target.checked); applyFrutigerAero(); if(game) game.checkAchievements(); }); elements.fullscreenBtn.addEventListener('click', () => { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`)); } else { document.exitFullscreen(); } }); applyFrutigerAero(); }
            function setupAchievementsUI() { const toggleAchievements = () => { globalAudioManager.play('click'); elements.achievementsScreen.classList.toggle('hidden'); }; elements.achievementsButtonMain.addEventListener('click', () => { populateAchievementsScreen(); toggleAchievements(); }); elements.closeAchievementsButton.addEventListener('click', toggleAchievements); }
            function setupCreditsUI() { const toggleCredits = () => { globalAudioManager.play('click'); elements.creditsScreen.classList.toggle('hidden'); }; elements.creditsButton.addEventListener('click', toggleCredits); elements.closeCreditsButton.addEventListener('click', toggleCredits); }
            function populateAchievementsScreen() { const container = elements.achievementsScreen.querySelector('.achievements-container'); container.innerHTML = ''; const unlocked = settings.get('unlockedAchievements'); for (const id in achievements) { const ach = achievements[id]; const isUnlocked = unlocked.includes(id); container.innerHTML += `<div class="achievement-item ${isUnlocked ? 'unlocked' : ''}"><span class="achievement-icon">${isUnlocked ? ach.icon : '‚ùì'}</span><div class="achievement-details"><h4>${isUnlocked ? ach.name : '??????'}</h4><p>${isUnlocked ? ach.description : 'Keep playing to unlock!'}</p></div></div>`; } }
            
            function setupDebugTools() {
                let keySequence = []; const secretCode = ['KeyA', 'KeyN', 'KeyD', 'KeyR', 'KeyE'];
                window.addEventListener('keydown', (e) => {
                    if (debugUnlocked) return; keySequence.push(e.code); keySequence.splice(-secretCode.length - 1, keySequence.length - secretCode.length);
                    if (keySequence.join('') === secretCode.join('')) { debugUnlocked = true; console.log("Debug Mode Unlocked!"); if(!elements.settingsScreen.classList.contains('hidden')) elements.debugPanel.classList.remove('hidden');}
                });
                elements.debugLevel.addEventListener('change', e => { if (game?.player) { game.player.level = parseInt(e.target.value) || 1; game.player.exp = 0; }});
                elements.debugDamage.addEventListener('change', e => { if (game?.player) game.player.projectileDamage = parseInt(e.target.value) || 5; });
                elements.debugMaxHp.addEventListener('change', e => { if (game?.player) { game.player.maxHp = parseInt(e.target.value) || 100; game.player.hp = game.player.maxHp; }});
                elements.godModeBtn.addEventListener('click', () => { if(game?.player) { game.player.isInvincible = !game.player.isInvincible; elements.godModeBtn.textContent = `God Mode (${game.player.isInvincible ? 'ON' : 'OFF'})`; } });
            }
            setupCharacterSelection(); setupSettingsUI(); setupAchievementsUI(); setupCreditsUI(); setupDebugTools();

            elements.startButton.addEventListener('click', startGame); elements.retryButton.addEventListener('click', () => { globalAudioManager.play('click'); location.reload(); }); elements.continueButton.addEventListener('click', () => game.togglePause()); elements.newGameButton.addEventListener('click', () => { if(game) game.audio.play('click'); location.reload(); });
            resizeCanvas();

            const upgrades = { 'Growth': { name: 'Growth', rarity: 'common', description: 'Max. HP +10', effect: (p) => { p.maxHp += 10; p.hp += 10; }}, 'Resist': { name: 'Resist', rarity: 'common', description: 'Defense +4%', effect: (p) => { p.defense += 0.04; }}, 'Swift': { name: 'Swift', rarity: 'common', description: 'Movement Speed +20%', effect: (p) => { p.speedModifier += 0.2; }}, 'Catalyst': { name: 'Catalyst', rarity: 'common', description: 'Projectile Damage +2', effect: (p) => { p.projectileDamage += 2; }}, 'Resonance': { name: 'Resonance', rarity: 'common', description: 'Atk Speed +12%', effect: (p) => { p.attackSpeedModifier += 0.12; }}, 'Eyesight': { name: 'Eyesight', rarity: 'common', description: 'Critical Chance +5%', effect: (p) => { p.critChance += 0.05; }}, 'Impulse': { name: 'Impulse', rarity: 'common', description: 'Jump Height +30%', effect: (p) => { p.jumpModifier += 0.3; }}, 'Renew': { name: 'Renew', rarity: 'common', description: 'Heal to Max. HP', effect: (p) => { p.hp = p.maxHp; }}, 'Magnify': { name: 'Magnify', rarity: 'common', description: 'Projectile size and damage +15%', effect: (p) => { p.projectileSizeModifier = (p.projectileSizeModifier || 1) + 0.15; p.projectileDamage *= 1.15; }}, 'Orb': { name: 'Orb', rarity: 'uncommon', description: 'Enemies have a 5% chance to drop a healing orb (+10 HP).', effect: (p) => { p.upgrades.healingOrbChance = (p.upgrades.healingOrbChance || 0) + 0.05; }}, 'Precision': { name: 'Precision', rarity: 'uncommon', description: 'Critical deals +50% damage', effect: (p) => { p.critDamageModifier += 0.5; }}, 'Growth+': { name: 'Growth+', rarity: 'uncommon', description: 'Max. HP +20', effect: (p) => { p.maxHp += 20; p.hp += 20; }}, 'Piercing_Shots': { name: 'Piercing Shots', rarity: 'uncommon', description: 'Projectiles can pierce 1 enemy.', effect: (p) => { p.pierceCount = (p.pierceCount || 0) + 1; }}, 'Multi_Shot': { name: 'Multi-Shot', rarity: 'uncommon', description: 'Fire an additional projectile.', effect: (p) => { p.projectileCount = (p.projectileCount || 1) + 1; }}, 'Frost_Bolt': { name: 'Frost Bolt', rarity: 'uncommon', description: 'Projectiles freeze enemies for 2 seconds.', effect: (p) => { p.upgrades.frostBolt = true; }}, 'Leech': { name: 'Leech', rarity: 'uncommon', description: 'Life Steal of 3% Damage', effect: (p) => { p.lifesteal = (p.lifesteal || 0) + 0.03; }}, 'Swift+': { name: 'Swift+', rarity: 'uncommon', description: 'Movement Speed +40%', effect: (p) => { p.speedModifier += 0.4; }}, 'Thunderbolt': { name: 'Thunderbolt', rarity: 'rare', description: 'Calls 2 thunderbolts from the sky every few seconds.', effect: (p) => { if(!p.upgrades.thunderbolt) p.upgrades.thunderbolt = { count: 0, interval: 4000, timer: 4000 }; p.upgrades.thunderbolt.count += 2; }}, 'Insight': { name: 'Insight', rarity: 'rare', description: 'Gain +1 card choice on level up. (Max 5)', effect: (p) => { p.upgradeChoices = Math.min(5, p.upgradeChoices + 1); }}, 'Repulsion_Field': { name: 'Repulsion Field', rarity: 'rare', description: 'An aura pushes enemies away from you.', effect: (p) => { p.upgrades.repulsionField = true; }}, 'Blink': { name: 'Blink', rarity: 'rare', description: 'Press SHIFT to dash towards your cursor.', effect: (p) => { p.upgrades.blink = { ready: true, cooldown: 3000, timer: 0 }; }}, 'Barrier': { name: 'Barrier', rarity: 'rare', description: 'Creates a shield that blocks damage once every few seconds.', effect: (p) => { if(!p.upgrades.barrier) p.upgrades.barrier = { ready: true, cooldown: 8000, timer: 8000 }; else p.upgrades.barrier.cooldown *= 0.9; }}, 'Wound': { name: 'Wound', rarity: 'rare', description: 'Dealing damage applies bleeding to the enemy.', effect: (p) => { p.upgrades.wound = true; }}, 'Cold': { name: 'Cold', rarity: 'rare', description: 'Enemies get 1% slower every time they take damage (up to 80%).', effect: (p) => { p.upgrades.cold = (p.upgrades.cold || 0) + 0.01; }}};
            const inputHandler = { keys: new Set(), mouse: { x: 0, y: 0, down: false }, init() { window.addEventListener('keydown', e => { this.keys.add(e.code); if (e.code === 'Escape' && game && (game.gameState === 'playing' || game.gameState === 'paused' || game.gameState === 'bossWave')) game.togglePause(); if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') if(game && game.player.upgrades.blink?.ready) game.player.dash(); }); window.addEventListener('keyup', e => this.keys.delete(e.code)); elements.canvas.addEventListener('mousemove', e => { const rect = elements.canvas.getBoundingClientRect(); this.mouse.x = e.clientX - rect.left; this.mouse.y = e.clientY - rect.top; }); elements.canvas.addEventListener('mousedown', () => this.mouse.down = true); elements.canvas.addEventListener('mouseup', () => this.mouse.down = false); } };
            inputHandler.init();
            
            class Player { constructor(game, characterType) { this.game = game; this.characterType = characterType; this.width = 32; this.height = 64; this.x = this.game.width / 2; this.y = this.game.height - this.height - 40; this.vx = 0; this.vy = 0; this.onGround = false; this.jumpsLeft = 2; this.maxJumps = 2; this.image = this.game.assets[this.characterType === 'gladiator' ? 'gladiator' : 'player']; this.weaponAngle = 0; this.weaponLength = 40; this.maxHp = 100; this.hp = this.maxHp; this.level = 1; this.exp = 0; this.expToNextLevel = 10; this.defense = 0; this.speedModifier = 1; this.jumpModifier = 1; this.projectileDamage = 5; this.attackSpeedModifier = 1; this.critChance = 0.05; this.critDamageModifier = 1.5; this.lifesteal = 0; this.upgradeChoices = 3; this.upgrades = {}; this.collectedUpgrades = []; this.projectileSizeModifier = 1; this.pierceCount = 0; this.projectileCount = 1; this.shootCooldown = 500; this.lastShotTime = 0; this.isInvincible = false; this.invincibilityDuration = 500; this.invincibilityTimer = 0; this.isDashing = false; this.distanceMoved = 0; this.statusEffects = { burn: { active: false, duration: 0, damagePerSecond: 0 }, silenced: { active: false, duration: 0 } }; if (this.characterType === 'gladiator') { this.maxHp = 60; this.hp = 60; this.shootCooldown = 2500; } } draw(ctx) { ctx.save(); if(this.upgrades.blink) { const blink = this.upgrades.blink; if(!blink.ready) { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.height/2 + 8, -Math.PI/2, -Math.PI/2 + (Math.PI*2) * (1 - blink.timer / blink.cooldown)); ctx.stroke(); } } ctx.translate(this.x + this.width / 2, this.y + this.height / 2 - 10); ctx.rotate(this.weaponAngle); if(this.characterType === 'wizard') { ctx.fillStyle = '#654321'; ctx.fillRect(0, -2, this.weaponLength, 4); if (settings.get('bloom')) { ctx.shadowBlur = 15; ctx.shadowColor = '#00FFFF'; } ctx.fillStyle = '#00FFFF'; ctx.beginPath(); ctx.arc(this.weaponLength, 0, 8, 0, Math.PI * 2); ctx.fill(); } else if (this.characterType === 'gladiator') { ctx.fillStyle = '#c0c0c0'; ctx.fillRect(0, -2, this.weaponLength, 4); if (settings.get('bloom')) { ctx.shadowBlur = 10; ctx.shadowColor = '#fff'; } ctx.fillStyle = '#f0f0f0'; ctx.beginPath(); ctx.moveTo(this.weaponLength, 0); ctx.lineTo(this.weaponLength - 10, -5); ctx.lineTo(this.weaponLength - 10, 5); ctx.closePath(); ctx.fill(); } ctx.restore(); if (this.statusEffects.burn.active) { for(let i=0; i<3; i++) this.game.particles.push(new Particle(this.game, this.x + Math.random() * this.width, this.y + Math.random() * this.height, 'orange', 0.5)); } ctx.globalAlpha = (this.isInvincible || this.isDashing) ? 0.5 : 1.0; if(this.image?.complete && this.image.width > 0) { ctx.drawImage(this.image, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = this.characterType === 'gladiator' ? '#6c757d' : '#8a2be2'; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.font = '32px VT323'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = 'white'; ctx.fillText(this.characterType === 'gladiator' ? 'G' : 'W', this.x + this.width / 2, this.y + this.height / 2); } ctx.globalAlpha = 1.0; if (this.upgrades.barrier?.ready) { if(settings.get('bloom')) { ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(100, 150, 255, 0.8)'; } ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.height/2 + 5, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur=0; } if (this.statusEffects.silenced.active) { ctx.fillStyle = 'white'; ctx.font = "30px VT323"; ctx.textAlign = 'center'; ctx.fillText('...', this.x + this.width / 2, this.y - 10); } } update(input, deltaTime) { if(this.upgrades.blink && !this.upgrades.blink.ready) { this.upgrades.blink.timer -= deltaTime; if(this.upgrades.blink.timer <= 0) this.upgrades.blink.ready = true; } if(this.isDashing) return; this.updateStatusEffects(deltaTime); const baseSpeed = 5; this.vx = 0; if (input.keys.has('KeyA')) this.vx = -baseSpeed * this.speedModifier; if (input.keys.has('KeyD')) this.vx = baseSpeed * this.speedModifier; this.x += this.vx; if(this.onGround && this.vx !== 0) this.distanceMoved += Math.abs(this.vx); this.vy += this.game.gravity; this.y += this.vy; this.onGround = false; this.game.platforms.forEach(platform => { if (this.x < platform.x + platform.width && this.x + this.width > platform.x && this.y < platform.y + platform.height && this.y + this.height > platform.y && this.vy >= 0 && this.y + this.height - this.vy <= platform.y) { this.onGround = true; this.jumpsLeft = this.maxJumps; this.y = platform.y - this.height; this.vy = 0; } }); if (this.x + this.width < 0) this.x = this.game.width - this.width; if (this.x > this.game.width) this.x = 0; if (this.isInvincible) { this.invincibilityTimer -= deltaTime; if (this.invincibilityTimer <= 0) this.isInvincible = false; } this.weaponAngle = Math.atan2(input.mouse.y - (this.y + this.height / 2 - 10) + this.game.cameraY, input.mouse.x - (this.x + this.width / 2) + this.game.cameraX); if (input.mouse.down && Date.now() - this.lastShotTime > this.shootCooldown / this.attackSpeedModifier) { this.attack(); this.lastShotTime = Date.now(); } } updateStatusEffects(deltaTime) { const burn = this.statusEffects.burn; if(burn.active) { burn.duration -= deltaTime; if(burn.duration <= 0) { burn.active = false; } else { this.hp -= burn.damagePerSecond * (deltaTime / 1000); if(this.hp <= 0) { this.hp = 0; this.game.gameOver(); } } } const silenced = this.statusEffects.silenced; if(silenced.active) { silenced.duration -= deltaTime; if(silenced.duration <= 0) silenced.active = false; } } applyBurn() { const burn = this.statusEffects.burn; burn.active = true; burn.duration = 3000; burn.damagePerSecond = this.maxHp * 0.05; } jump() { if (this.jumpsLeft > 0) { this.game.audio.play('jump'); this.vy = -12 * this.jumpModifier; this.jumpsLeft--; this.onGround = false; } } attack() { if (this.characterType === 'wizard') { this.shoot(); } else if (this.characterType === 'gladiator') { this.meleeAttack(); } } shoot() { if(this.statusEffects.silenced.active) return; this.game.audio.play('bullet'); const spread = Math.PI / 18; for (let i = 0; i < this.projectileCount; i++) { const angleOffset = (i - (this.projectileCount - 1) / 2) * spread; const angle = this.weaponAngle + angleOffset; const startX = this.x + this.width / 2 + Math.cos(angle) * this.weaponLength; const startY = this.y + this.height / 2 - 10 + Math.sin(angle) * this.weaponLength; this.game.projectiles.push(new Projectile(this.game, startX, startY, angle, this)); } } meleeAttack() { this.game.audio.play('jump', 0.8); const startX = this.x + this.width / 2; const startY = this.y + this.height / 2 - 10; this.game.effects.push(new SlashEffect(this.game, startX, startY, this.weaponAngle, this)); } dash() { this.isDashing = true; this.upgrades.blink.ready = false; this.upgrades.blink.timer = this.upgrades.blink.cooldown; const dashAngle = this.weaponAngle; const dashDistance = 200; for(let i=0; i<20; i++) this.game.particles.push(new Particle(this.game, this.x + this.width/2 + (Math.random()-0.5)*20, this.y + this.height/2 + (Math.random()-0.5)*20, 'cyan')); let newX = this.x + Math.cos(dashAngle) * dashDistance; let newY = this.y + Math.sin(dashAngle) * dashDistance; this.x = Math.max(0, Math.min(newX, this.game.width - this.width)); this.y = Math.max(0, Math.min(newY, this.game.height - this.height)); for(let i=0; i<20; i++) this.game.particles.push(new Particle(this.game, this.x + this.width/2 + (Math.random()-0.5)*20, this.y + this.height/2 + (Math.random()-0.5)*20, 'cyan')); this.isDashing = false; } takeDamage(damage) { if (this.isInvincible || this.isDashing) return; if (this.upgrades.barrier?.ready) { this.upgrades.barrier.ready = false; this.isInvincible = true; this.invincibilityTimer = 300; this.game.audio.play('playerDamage', 0.2); return; } this.game.audio.play('playerDamage'); this.hp -= Math.max(1, damage * (1 - this.defense)); this.isInvincible = true; this.invincibilityTimer = this.invincibilityDuration; this.game.triggerScreenShake(); if (this.hp <= 0) { this.hp = 0; this.game.gameOver(); } } gainExp(killCount = 1) { this.exp += killCount; if (this.exp >= this.expToNextLevel) { this.level++; this.exp = 0; this.expToNextLevel = 10 + this.level * 2; this.game.levelUp(); } } applyUpgrade(upgradeId) { const upgrade = upgrades[upgradeId]; if(upgrade && upgrade.effect) { upgrade.effect(this); this.collectedUpgrades.push(upgradeId); } this.game.checkAchievements(); } }
            class Enemy { constructor(game, playerLevel, type = 'basic') { this.game = game; this.type = type; const scaleFactor = 1 + Math.min((playerLevel - 1) * 0.1, 1.5); this.x = Math.random() * (game.width - 40); this.y = -50; this.state = 'descending'; this.targetY = game.enemyKeepAwayY + Math.random() * (game.height * 0.2); this.markedForDeletion = false; this.angle = 0; this.statusEffects = { bleed: { damage: 0, duration: 0 }, cold: { amount: 0, duration: 0 }, frozen: { active: false, timer: 0 } }; switch(this.type) { case 'eye': this.image = this.game.assets.eye; this.width = 42 * scaleFactor; this.height = 37 * scaleFactor; this.speed = 0.8 + Math.random() * 0.4 + game.wave * 0.03; this.maxHp = (8 + game.wave * 1.5) * scaleFactor; this.damage = (4 + game.wave * 0.8) * scaleFactor; this.shootCooldown = Math.max(600, 2000 - game.wave * 35); this.expValue = Math.floor(1 * scaleFactor); break; case 'demon': this.image = this.game.assets.demon; this.width = 36 * scaleFactor; this.height = 34 * scaleFactor; this.speed = 0.6 + Math.random() * 0.2 + game.wave * 0.02; this.maxHp = (40 + game.wave * 6) * scaleFactor; this.damage = (8 + game.wave * 1.2) * scaleFactor; this.shootCooldown = Math.max(2000, 4500 - game.wave * 60); this.expValue = Math.floor(4 * scaleFactor); break; default: this.image = this.game.assets.enemy; this.width = 32 * scaleFactor; this.height = 19 * scaleFactor; this.speed = 1 + Math.random() * 0.5 + game.wave * 0.05; this.maxHp = (10 + game.wave * 2) * scaleFactor; this.damage = (5 + game.wave) * scaleFactor; this.shootCooldown = Math.max(800, 2500 - game.wave * 40); this.expValue = Math.floor(1 * scaleFactor); break; } this.hp = this.maxHp; this.lastShotTime = Date.now() + Math.random() * 1000; } draw(ctx) { ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.angle); if(this.image?.complete) ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height); if(this.statusEffects.frozen.active) { ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height); } ctx.restore(); if(this.hp < this.maxHp) { ctx.fillStyle = 'rgba(255,0,0,0.7)'; ctx.fillRect(this.x, this.y - 8, this.width, 4); ctx.fillStyle = 'rgba(0,255,0,0.7)'; ctx.fillRect(this.x, this.y - 8, this.width * (this.hp/this.maxHp), 4); } } update(player, otherEnemies, deltaTime) { this.updateStatusEffects(deltaTime); if(this.statusEffects.frozen.active) return; if(player.upgrades.repulsionField) { const dx = this.x - player.x; const dy = this.y - player.y; const distance = Math.hypot(dx, dy); if(distance < 150) { const angle = Math.atan2(dy, dx); this.x += Math.cos(angle) * 2; this.y += Math.sin(angle) * 2; } } let currentSpeed = this.speed * (1 - this.statusEffects.cold.amount); if (this.state === 'descending') { this.y += currentSpeed; if (this.y >= this.targetY) this.state = 'following'; } else if (this.state === 'following') { const dx = player.x - this.x; const dy = player.y - this.y; this.angle = Math.atan2(dy, dx) + Math.PI / 2; this.x += dx * 0.01 * currentSpeed; this.y += dy * 0.01 * currentSpeed; this.y = Math.max(this.y, this.game.enemyKeepAwayY); if (Date.now() - this.lastShotTime > this.shootCooldown) { this.shoot(player); this.lastShotTime = Date.now(); } } otherEnemies.forEach(other => { if(this === other) return; const dist = Math.hypot(this.x - other.x, this.y - other.y); if (dist < this.width) { const angle = Math.atan2(this.y - other.y, this.x - other.x); this.x += Math.cos(angle) * (this.width - dist) / 2; this.y += Math.sin(angle) * (this.width - dist) / 2; } }); } updateStatusEffects(deltaTime) { if (this.statusEffects.bleed.duration > 0) { this.takeDamage(this.statusEffects.bleed.damage * (deltaTime / 1000)); this.statusEffects.bleed.duration -= deltaTime; } if (this.statusEffects.cold.duration > 0) this.statusEffects.cold.duration -= deltaTime; else this.statusEffects.cold.amount = 0; if (this.statusEffects.frozen.active) { this.statusEffects.frozen.timer -= deltaTime; if(this.statusEffects.frozen.timer <= 0) this.statusEffects.frozen.active = false; } } shoot(player) { const angle = Math.atan2(player.y - this.y, player.x - this.x); let projectileType = 'normal'; if (this.type === 'demon') projectileType = 'fireball'; if (this.type === 'eye') projectileType = 'silencing_beam'; this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, angle, this, projectileType)); } takeDamage(amount, source) { this.hp -= amount; if (this.hp <= 0 && !this.markedForDeletion) { this.markedForDeletion = true; this.game.audio.play('enemyDeath'); this.game.createExplosion(this.x + this.width/2, this.y + this.height/2, this.width); if (source instanceof Player) { settings.set('totalKills', settings.get('totalKills') + 1); this.game.checkAchievements(); source.gainExp(this.expValue); if (source.upgrades.fragmentation) { for (let i = 0; i < source.upgrades.fragmentation; i++) this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, Math.random() * Math.PI * 2, source, 'fragment')); } if (source.upgrades.healingOrbChance && Math.random() < source.upgrades.healingOrbChance) { this.game.healingOrbs.push(new HealingOrb(this.game, this.x + this.width / 2, this.y + this.height / 2)); } } } } }
            class Projectile { constructor(game, x, y, angle, owner, type = 'normal') { this.game = game; this.x = x; this.y = y; this.owner = owner; this.type = type; this.pierce = (owner instanceof Player) ? owner.pierceCount : 0; let speed = (owner instanceof Player) ? 10 : 5; this.radius = 5 * ((owner instanceof Player) ? owner.projectileSizeModifier : 1); this.isBeam = false; if (this.type === 'fragment') { this.damage = owner.projectileDamage * 0.5; this.color = '#add8e6'; speed = 7; this.radius=3; } else if (this.type === 'silencing_beam') { this.color = '#dda0dd'; this.damage = 1; this.radius = 8; speed = 3; this.isBeam = true; } else if (owner instanceof Player) { this.damage = owner.projectileDamage; this.color = '#00FFFF'; } else { this.damage = owner.damage; this.color = 'red'; } this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.markedForDeletion = false; this.trail = []; } draw(ctx) { ctx.save(); if (settings.get('bloom')) { ctx.shadowBlur = 10; ctx.shadowColor = this.color; } this.trail.forEach(t => { ctx.fillStyle = t.color; ctx.globalAlpha = t.alpha; ctx.beginPath(); ctx.arc(t.x, t.y, this.radius-2 > 0 ? this.radius-2 : 1, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0; if (this.isBeam) { ctx.translate(this.x, this.y); ctx.rotate(Math.atan2(this.vy, this.vx)); ctx.fillStyle = this.color; ctx.fillRect(-this.radius * 2, -this.radius / 2, this.radius * 4, this.radius); } else if (this.type === 'fireball') { ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } else { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); } update() { this.trail.push({x: this.x, y: this.y, alpha: 1.0, color: this.color}); this.trail.forEach(t => t.alpha -= 0.08); this.trail = this.trail.filter(t => t.alpha > 0); this.x += this.vx; this.y += this.vy; if (this.x < -this.radius || this.x > this.game.width + this.radius || this.y < -this.radius || this.y > this.game.height + this.radius) this.markedForDeletion = true; } }
            class HealingOrb { constructor(game, x, y) { this.game = game; this.x = x; this.y = y; this.vy = 0; this.radius = 8; this.markedForDeletion = false; this.bobAngle = Math.random() * Math.PI * 2; this.onGround = false; } update() { this.bobAngle += 0.1; if (!this.onGround) { this.vy += this.game.gravity * 0.5; this.y += this.vy; this.game.platforms.forEach(platform => { if (this.x > platform.x && this.x < platform.x + platform.width && this.y + this.radius > platform.y && this.y < platform.y + platform.height) { this.y = platform.y - this.radius; this.vy *= -0.4; if (Math.abs(this.vy) < 1) { this.onGround = true; this.vy = 0; } } }); } } draw(ctx) { const bobY = this.onGround ? Math.sin(this.bobAngle) * 3 : 0; ctx.save(); if(settings.get('bloom')) { ctx.shadowBlur = 15; ctx.shadowColor = '#33ff33'; } ctx.globalAlpha = 0.8; ctx.fillStyle = '#33ff33'; ctx.beginPath(); ctx.arc(this.x, this.y + bobY, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#ffffff'; ctx.stroke(); ctx.restore(); } }
            class DamageNumber { constructor(game, x, y, amount, isCrit) { this.game = game; this.x = x; this.y = y; this.text = Math.floor(amount); this.life = 1000; this.vy = -1; this.isCrit = isCrit; } update(deltaTime) { this.y += this.vy * (deltaTime/16); this.life -= deltaTime; if (this.life <= 0) this.markedForDeletion = true; } draw(ctx) { ctx.save(); ctx.globalAlpha = this.life / 1000; ctx.font = this.isCrit ? "24px VT323" : "18px VT323"; ctx.fillStyle = this.isCrit ? "yellow" : "white"; if(settings.get('bloom')) { ctx.shadowBlur = this.isCrit ? 10 : 5; ctx.shadowColor = this.isCrit ? "yellow" : "white"; } else { ctx.shadowColor = 'black'; ctx.shadowBlur = 4; } ctx.fillText(this.text, this.x, this.y); ctx.restore(); } }
            class Platform { constructor(x, y, width, height) { this.x = x; this.y = y; this.width = width; this.height = height; } draw(ctx) { const isAero = settings.get('frutigerAero'); ctx.fillStyle = isAero ? 'rgba(150, 200, 255, 0.2)' : 'transparent'; ctx.strokeStyle = isAero ? 'rgba(230, 245, 255, 0.7)' : '#fff'; ctx.lineWidth = isAero ? 3 : 2; if (isAero) ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); } }
            class Star { constructor(game) { this.game = game; this.parallax = Math.random() * 0.4 + 0.1; this.reset(); } reset() { this.x = Math.random() * this.game.width; this.y = Math.random() * this.game.height; this.size = Math.random() * 1.5 + 0.5; this.brightness = Math.random() * 0.5 + 0.5; } update() { this.y += 0.1; if (this.y > this.game.height) { this.y = 0; this.x = Math.random() * this.game.width; } } draw(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`; ctx.fillRect(this.x, this.y, this.size, this.size); } }
            class Particle { constructor(game, x, y, color, sizeMultiplier=1) { this.game = game; this.x = x; this.y = y; this.color = color; this.size = (Math.random() * 3 + 1) * sizeMultiplier; this.life = Math.random() * 500 + 200; this.vx = Math.random() * 4 - 2; this.vy = Math.random() * 4 - 2; this.markedForDeletion = false; } draw(ctx) { ctx.save(); if(settings.get('bloom')) { ctx.shadowBlur = 10; ctx.shadowColor = this.color; } ctx.globalAlpha = this.life / 500; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.restore(); } update(deltaTime) { this.x += this.vx; this.y += this.vy; this.life -= deltaTime; if(this.life <= 0) this.markedForDeletion = true; } }
            class Notifier { constructor(game, text, title, icon, color) { this.game = game; this.text = text; this.title = title; this.icon = icon; this.color = color; this.width = 400; this.height = 50; this.x = game.width / 2 - this.width / 2; this.y = -this.height; this.targetY = 10; this.life = 4000; this.state = 'sliding_in'; } update(deltaTime) { this.life -= deltaTime; if(this.state === 'sliding_in') { this.y += (this.targetY - this.y) * 0.1; if(Math.abs(this.y - this.targetY) < 1) { this.y = this.targetY; this.state = 'waiting'; } } if(this.life <= 1000) { this.state = 'fading_out'; } if(this.life <= 0) this.markedForDeletion = true; } draw(ctx) { ctx.save(); if(this.state === 'fading_out') ctx.globalAlpha = this.life / 1000; ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.strokeStyle = this.color; ctx.lineWidth = 3; if (ctx.roundRect) { ctx.roundRect(this.x, this.y, this.width, this.height, [10]); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); } ctx.fillStyle = this.color; ctx.font = "20px Cinzel"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(`${this.icon} ${this.title}`, this.x + this.width / 2, this.y + this.height * 0.35); ctx.fillStyle = 'white'; ctx.font = "16px VT323"; ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height * 0.7); ctx.restore(); } }
            class SlashEffect { constructor(game, x, y, angle, owner) { this.game = game; this.x = x; this.y = y; this.startAngle = angle - Math.PI / 4; this.endAngle = angle + Math.PI / 4; this.radius = 70; this.life = 150; this.owner = owner; this.damage = 999; this.hitEnemies = new Set(); this.markedForDeletion = false; } update(deltaTime) { this.life -= deltaTime; if (this.life <= 0) { this.markedForDeletion = true; } } draw(ctx) { ctx.save(); ctx.globalAlpha = (this.life / 150) * 0.8; ctx.fillStyle = 'white'; if(settings.get('bloom')) { ctx.shadowBlur = 15; ctx.shadowColor = '#fff'; } ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle); ctx.closePath(); ctx.fill(); ctx.restore(); } }
            class Boss extends Enemy { constructor(game, level) { super(game, level, 'boss'); this.level = level; this.state = 'intro'; this.targetY = game.height * 0.15; this.attackPattern = [{ type: 'multi-shot', duration: 6000, timer: 6000 }, { type: 'spawn-minions', duration: 12000, timer: 12000 }, { type: 'red-lightning', duration: 7000, timer: 7000 }]; if (level === 5) { this.image = this.game.assets.boss1; this.width = 62 * 2; this.height = 67 * 2; this.maxHp = 1000 + game.wave * 50; } else { this.image = this.game.assets.boss2; this.width = 63 * 2; this.height = 61 * 2; this.maxHp = 2000 + game.wave * 100; } this.hp = this.maxHp; this.introMoveDir = 1; this.introSpeed = 1; } update(player, otherEnemies, deltaTime) { if (this.state === 'intro') { this.y += (this.targetY - this.y) * 0.02; this.x += this.introMoveDir * this.introSpeed; if (this.x > this.game.width * 0.7 || this.x < this.game.width * 0.3) { this.introMoveDir *= -1; } return; } if (this.state === 'active') { this.attackPattern.forEach(pattern => { pattern.timer -= deltaTime; if (pattern.timer <= 0) { pattern.timer = pattern.duration; if(pattern.type === 'multi-shot') this.multiShot(player); if(pattern.type === 'spawn-minions') this.spawnMinions(3); if(pattern.type === 'red-lightning') this.redLightning(player); } }); } } multiShot(player) { const numShots = 5; const spread = Math.PI / 8; for (let i = 0; i < numShots; i++) { const angle = Math.atan2(player.y - this.y, player.x - this.x) + (i - (numShots - 1) / 2) * spread; this.game.projectiles.push(new Projectile(this.game, this.x + this.width / 2, this.y + this.height / 2, angle, this)); } } spawnMinions(count) { for(let i=0; i<count; i++) { const minion = new Enemy(this.game, this.game.player.level, 'basic'); minion.x = this.x + (Math.random() - 0.5) * this.width; minion.y = this.y + this.height; this.game.enemies.push(minion); } } redLightning(player) { this.game.createThunderboltEffect(player.x, '#d44'); this.game.createThunderboltEffect(this.game.width - player.x, '#d44'); } draw(ctx) { super.draw(ctx); const barWidth = this.game.width * 0.6; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(this.game.width * 0.2 - 2, 18, barWidth + 4, 24); ctx.fillStyle = '#550000'; ctx.fillRect(this.game.width * 0.2, 20, barWidth, 20); ctx.fillStyle = '#c0392b'; ctx.fillRect(this.game.width * 0.2, 20, barWidth * (this.hp / this.maxHp), 20); } }
            class DialogueBox { constructor(game, text) { this.game = game; this.fullText = text; this.displayedText = ''; this.charIndex = 0; this.typingSpeed = 50; this.timer = 0; this.isFinished = false; this.x = this.game.width * 0.1; this.y = this.game.height * 0.75; this.width = this.game.width * 0.8; this.height = this.game.height * 0.2; } update(deltaTime) { if (this.isFinished) return; this.timer += deltaTime; if (this.timer >= this.typingSpeed) { this.timer = 0; if (this.charIndex < this.fullText.length) { this.displayedText += this.fullText[this.charIndex]; this.charIndex++; this.game.audio.play('key', 0.4); } else { setTimeout(() => this.isFinished = true, 1000); } } } draw(ctx) { ctx.save(); ctx.globalAlpha = 0.8; ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); ctx.fillStyle = 'white'; ctx.font = '24px VT323'; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; const lines = this.displayedText.split('\n'); lines.forEach((line, i) => { ctx.fillText(line, this.x + 20, this.y + 20 + (i * 28)); }); ctx.restore(); } }
            class CutsceneManager { constructor(game, level) { this.game = game; this.level = level; this.state = 'dialogue_start'; this.dialogueBox = null; this.boss = null; } update(deltaTime) { switch (this.state) { case 'dialogue_start': const text = this.level === 5 ? "You've survived... for now.\nLet's see how you handle a real threat." : "Impressive. But your stand ends here.\nFace oblivion!"; this.dialogueBox = new DialogueBox(this.game, text); this.state = 'dialogue_typing'; break; case 'dialogue_typing': this.dialogueBox.update(deltaTime); if (this.dialogueBox.isFinished) { this.state = 'boss_reveal'; } break; case 'boss_reveal': this.dialogueBox = null; this.boss = new Boss(this.game, this.level); this.game.enemies.push(this.boss); this.game.cameraZoomTarget = 0.8; this.game.audio.startMusic(`boss${this.level === 5 ? 1 : 2}`); this.state = 'camera_pan'; break; case 'camera_pan': if (Math.abs(this.game.cameraZoom - this.game.cameraZoomTarget) < 0.01) { this.state = 'finished'; } break; case 'finished': this.boss.state = 'active'; this.game.endCutscene(); break; } } draw(ctx) { if (this.dialogueBox) { this.dialogueBox.draw(ctx); } } }

            class Game {
                constructor(width, height, images, audioManager, characterType) { this.width = width; this.height = height; this.assets = images; this.audio = audioManager; this.player = new Player(this, characterType); this.platforms = this.createPlatforms(); this.enemies = []; this.projectiles = []; this.particles = []; this.healingOrbs = []; this.effects = []; this.damageNumbers = []; this.notifiers = []; this.stars = []; this.createStars(); this.gravity = 0.5; this.gameState = 'playing'; this.wave = 1; this.score = 0; this.lastTime = 0; this.enemyKeepAwayY = this.height * 0.1; this.cameraX = 0; this.cameraY = 0; this.cameraSmoothing = 0.05; this.cameraZoom = 1.0; this.cameraZoomTarget = 1.0; this.rerollsUsedThisLevel = false; this.bossActive = false; this.bossDefeatedLevels = []; this.cutsceneManager = null; this.setupInput(); }
                createPlatforms() { return [ new Platform(0, this.height - 40, this.width, 40), new Platform(100, this.height - 120, 150, 20), new Platform(this.width - 250, this.height - 120, 150, 20), new Platform(this.width/2 - 100, this.height - 200, 200, 20), new Platform(this.width/2 - 350, this.height - 300, 150, 20), new Platform(this.width/2 + 200, this.height - 300, 150, 20)]; }
                createStars() { this.stars = []; for(let i=0; i < 200; i++) this.stars.push(new Star(this)); }
                setupInput() { window.addEventListener('keydown', e => { if(e.code === 'Space' && (this.gameState === 'playing' || this.gameState === 'bossWave')) this.player.jump(); }); }
                update(timestamp) { const deltaTime = (timestamp - (this.lastTime || timestamp)) || 16.67; this.lastTime = timestamp; this.updateCamera(); this.stars.forEach(s => s.update()); if (this.gameState === 'cutscene') { this.cutsceneManager.update(deltaTime); this.enemies.forEach(e => e.update(this.player, this.enemies, deltaTime)); this.player.update(inputHandler, deltaTime); return; } this.score += deltaTime/10; this.wave = 1 + Math.floor(this.player.level / 2); if(this.player.y > this.height + 200) this.handleOutOfBounds(); this.player.update(inputHandler, deltaTime); const bossLevel = [5, 10].find(lvl => this.player.level >= lvl && !this.bossDefeatedLevels.includes(lvl) && !this.bossActive); if(bossLevel) { this.startBossCutscene(bossLevel); } if (this.gameState === 'playing') { const maxEnemies = 2 + Math.floor(this.player.level * 1.2); if (this.enemies.length < maxEnemies) { let spawnPool = ['basic', 'basic', 'basic']; if (this.player.level >= 4) spawnPool.push('eye', 'eye'); if (this.player.level >= 8) spawnPool.push('demon'); const enemyType = spawnPool[Math.floor(Math.random() * spawnPool.length)]; this.enemies.push(new Enemy(this, this.player.level, enemyType)); } } this.enemies.forEach(e => e.update(this.player, this.enemies, deltaTime)); this.projectiles.forEach(p => p.update()); this.particles.forEach(p => p.update(deltaTime)); this.healingOrbs.forEach(o => o.update()); this.damageNumbers.forEach(dn => dn.update(deltaTime)); this.notifiers.forEach(an => an.update(deltaTime)); this.updateUpgrades(deltaTime); this.updateEffects(deltaTime); this.checkCollisions(); const boss = this.enemies.find(e => e instanceof Boss); if (this.bossActive && boss && boss.markedForDeletion) { this.endBossWave(boss.level); } this.enemies = this.enemies.filter(e => !e.markedForDeletion); this.projectiles = this.projectiles.filter(p => !p.markedForDeletion); this.particles = this.particles.filter(p => !p.markedForDeletion); this.healingOrbs = this.healingOrbs.filter(o => !o.markedForDeletion); this.effects = this.effects.filter(e => !e.markedForDeletion); this.damageNumbers = this.damageNumbers.filter(dn => !dn.markedForDeletion); this.notifiers = this.notifiers.filter(an => !an.markedForDeletion); elements.hpText.textContent = `HP: ${Math.ceil(this.player.hp)}/${this.player.maxHp}`; elements.expText.textContent = `LVL: ${this.player.level}`; elements.hpBar.style.width = `${(this.player.hp / this.player.maxHp) * 100}%`; elements.expBar.style.width = `${(this.player.exp / this.player.expToNextLevel) * 100}%`; }
                handleOutOfBounds() { this.player.takeDamage(1); this.notifiers.push(new Notifier(this, "We're working on that bug!", "You fell into the void...", 'üêõ', '#ff4757')); this.player.x = this.width / 2; this.player.y = this.height / 2; this.player.vy = 0; }
                startBossCutscene(level) { this.gameState = 'cutscene'; this.bossActive = true; this.enemies = []; this.audio.stopAllMusic(); this.cutsceneManager = new CutsceneManager(this, level); }
                endCutscene() { this.cutsceneManager = null; this.gameState = 'bossWave'; }
                endBossWave(level) { this.gameState = 'playing'; this.bossActive = false; this.bossDefeatedLevels.push(level); this.player.gainExp(50); this.audio.startMusic('soundtrack'); this.cameraZoomTarget = 1.0; }
                updateCamera() { this.cameraZoom += (this.cameraZoomTarget - this.cameraZoom) * 0.02; let targetX = this.player.x + this.player.width / 2 - this.width / 2; let targetY = this.player.y + this.player.height / 2 - this.height / 2; if (this.gameState === 'cutscene' && this.cutsceneManager?.state === 'dialogue_typing') { /* Lock on player for dialogue */ } else if (this.bossActive || (this.cutsceneManager && this.cutsceneManager.state === 'camera_pan')) { const boss = this.enemies.find(e => e instanceof Boss); if (boss) { targetY = (this.player.y + boss.y) / 2 - this.height / 2; } } if (settings.get('cameraSmoothing')) { this.cameraX += (targetX - this.cameraX) * this.cameraSmoothing; this.cameraY += (targetY - this.cameraY) * this.cameraSmoothing; } else { this.cameraX = targetX; this.cameraY = targetY; } }
                draw(ctx) { ctx.save(); ctx.translate(this.width/2, this.height/2); ctx.scale(this.cameraZoom, this.cameraZoom); ctx.translate(-this.width/2, -this.height/2); ctx.save(); ctx.translate(-this.cameraX * 0.2, -this.cameraY * 0.2); this.stars.forEach(s => { if(s.parallax > 0.3) s.draw(ctx) }); ctx.restore(); ctx.save(); ctx.translate(-this.cameraX * 0.4, -this.cameraY * 0.4); this.stars.forEach(s => { if(s.parallax <= 0.3) s.draw(ctx) }); ctx.restore(); ctx.translate(-this.cameraX, -this.cameraY); this.platforms.forEach(p => p.draw(ctx)); this.effects.forEach(e => e.draw(ctx)); this.healingOrbs.forEach(o => o.draw(ctx)); this.player.draw(ctx); this.enemies.forEach(e => e.draw(ctx)); this.projectiles.forEach(p => p.draw(ctx)); this.particles.forEach(p => p.draw(ctx)); this.damageNumbers.forEach(dn => dn.draw(ctx)); ctx.restore(); this.notifiers.forEach(an => an.draw(ctx)); if (this.cutsceneManager) { this.cutsceneManager.draw(ctx); } }
                updateUpgrades(deltaTime) { if (this.player.upgrades.thunderbolt) { const tb = this.player.upgrades.thunderbolt; tb.timer -= deltaTime; if (tb.timer <= 0) { tb.timer = tb.interval; for (let i = 0; i < tb.count; i++) this.createThunderboltEffect(); } } if (this.player.upgrades.barrier) { const ba = this.player.upgrades.barrier; if(!ba.ready) { ba.timer -= deltaTime; if(ba.timer <= 0) { ba.ready = true; ba.timer = ba.cooldown; } } } if (this.player.upgrades.friction && this.player.distanceMoved > 100) { const count = this.player.upgrades.friction; for (let i = 0; i < count; i++) this.projectiles.push(new Projectile(this, this.player.x + this.player.width/2, this.player.y + this.player.height, -Math.PI / 2, this.player)); this.player.distanceMoved = 0; } }
                updateEffects(deltaTime) { this.effects.forEach(effect => effect.update(deltaTime)); }
                checkAchievements() { const unlocked = settings.get('unlockedAchievements'); for(const id in achievements) { if(!unlocked.includes(id) && achievements[id].check(this)) { unlocked.push(id); settings.set('unlockedAchievements', unlocked); this.notifiers.push(new Notifier(this, achievements[id].name, 'Achievement Unlocked!', 'üèÜ', 'gold')); } } }
                createThunderboltEffect(strikeX, color = 'yellow') { const strikeColor = color === '#d44' ? 'rgba(255, 100, 100, 0.4)' : 'rgba(255, 255, 100, 0.3)'; const damage = color === '#d44' ? 80 : 50; const radius = 60; const warningTime = 1500; const strikeTime = 200; const effect = { x: strikeX, timer: warningTime, state: 'warning', markedForDeletion: false, update: (delta) => { effect.timer -= delta; if (effect.timer <= 0) { if (effect.state === 'warning') { effect.state = 'strike'; effect.timer = strikeTime; this.triggerScreenShake(); this.enemies.forEach(enemy => { const dist = Math.abs(enemy.x + enemy.width / 2 - strikeX); if (dist < radius) { enemy.takeDamage(damage, this.player); if (settings.get('showDamageNumbers')) this.damageNumbers.push(new DamageNumber(this, enemy.x + enemy.width / 2, enemy.y, damage, false)); } }); for(let i=0; i<50; i++) this.particles.push(new Particle(this, strikeX + (Math.random() - 0.5) * radius * 2, color, 1.5)); } else { effect.markedForDeletion = true; } } }, draw: (ctx) => { if (effect.state === 'warning') { const alpha = 1 - (effect.timer / warningTime); ctx.fillStyle = strikeColor; ctx.beginPath(); ctx.ellipse(strikeX, this.height - 20, radius, radius/4, 0, 0, Math.PI * 2); ctx.fill(); } else if (effect.state === 'strike') { ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 5; if(settings.get('bloom')) { ctx.shadowColor = color; ctx.shadowBlur = 20; } ctx.beginPath(); ctx.moveTo(strikeX, 0); let currentX = strikeX; for (let y = 0; y < this.height; y += 20) { currentX += (Math.random() - 0.5) * 30; ctx.lineTo(currentX, y); } ctx.lineTo(currentX, this.height); ctx.stroke(); ctx.restore(); } } }; this.effects.push(effect); }
                checkCollisions() { this.projectiles.forEach(p => { if (p.owner instanceof Player) { this.enemies.forEach(e => { if(!e.markedForDeletion && this.rectCircleColliding({ x: e.x, y: e.y, width: e.width, height: e.height }, { x: p.x, y: p.y, r: p.radius })) { const isCrit = Math.random() < this.player.critChance; const damage = isCrit ? p.damage * this.player.critDamageModifier : p.damage; e.takeDamage(damage, p.owner); if (settings.get('showDamageNumbers')) this.damageNumbers.push(new DamageNumber(this, e.x + e.width / 2, e.y, damage, isCrit)); if(p.owner.upgrades.frostBolt) { e.statusEffects.frozen.active = true; e.statusEffects.frozen.timer = 2000; } if(this.player.lifesteal > 0) this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.lifesteal * damage); if(this.player.upgrades.wound) e.statusEffects.bleed = { damage: p.damage * 0.5, duration: 3000 }; if(this.player.upgrades.cold) { e.statusEffects.cold.amount = Math.min(0.8, (e.statusEffects.cold.amount || 0) + this.player.upgrades.cold); e.statusEffects.cold.duration = 2000; } if(p.pierce <= 0) p.markedForDeletion = true; else p.pierce--; }}); } else { if(this.rectCircleColliding({x: this.player.x, y: this.player.y, width: this.player.width, height: this.player.height}, {x: p.x, y: p.y, r: p.radius})) { if (p.type === 'silencing_beam') { this.player.takeDamage(p.damage); this.player.statusEffects.silenced = { active: true, duration: 2000 }; } else { this.player.takeDamage(p.damage); if (p.type === 'fireball') this.player.applyBurn(); } p.markedForDeletion = true; } } }); this.effects.forEach(effect => { if(effect instanceof SlashEffect) { this.enemies.forEach(enemy => { if (!effect.hitEnemies.has(enemy)) { const dist = Math.hypot(enemy.x + enemy.width / 2 - effect.x, enemy.y + enemy.height / 2 - effect.y); if (dist < effect.radius) { enemy.takeDamage(effect.damage, effect.owner); if (settings.get('showDamageNumbers')) this.damageNumbers.push(new DamageNumber(this, enemy.x + enemy.width / 2, enemy.y, effect.damage, true)); effect.hitEnemies.add(enemy); } } }); } }); this.healingOrbs.forEach(orb => { if (this.rectCircleColliding({ x: this.player.x, y: this.player.y, width: this.player.width, height: this.player.height }, { x: orb.x, y: orb.y, r: orb.radius * 2 })) { this.player.hp = Math.min(this.player.maxHp, this.player.hp + 10); this.audio.play('cardPickup', 0.6); orb.markedForDeletion = true; } }); }
                rectCircleColliding(rect, circle) { let testX = circle.x, testY = circle.y; if (circle.x < rect.x) testX = rect.x; else if (circle.x > rect.x + rect.width) testX = rect.x + rect.width; if (circle.y < rect.y) testY = rect.y; else if (circle.y > rect.y + rect.height) testY = rect.y + rect.height; return Math.hypot(circle.x - testX, circle.y - testY) <= circle.r; }
                triggerScreenShake() { elements.gameContainer.classList.add('shake'); setTimeout(() => elements.gameContainer.classList.remove('shake'), 100); }
                togglePause() { if (this.gameState === 'cutscene') return; if(elements.settingsScreen.classList.contains('hidden') && elements.achievementsScreen.classList.contains('hidden')) { this.gameState = this.gameState === 'playing' || this.gameState === 'bossWave' ? 'paused' : (this.bossActive ? 'bossWave' : 'playing'); if (this.gameState === 'paused') { this.updatePauseScreenInfo(); this.audio.stopAllMusic(); } else { if (this.bossActive) this.audio.startMusic(`boss${this.bossDefeatedLevels.length === 0 ? 1: 2}`); else this.audio.startMusic('soundtrack'); } elements.pauseScreen.classList.toggle('hidden'); this.audio.play('click'); } }
                updatePauseScreenInfo() { const statsContainer = document.getElementById('pauseStats'); const upgradesContainer = document.getElementById('pauseUpgrades'); statsContainer.innerHTML = '<h3>Player Stats</h3>'; upgradesContainer.innerHTML = '<h3>Current Upgrades</h3>'; const p = this.player; statsContainer.innerHTML += `<p>HP: ${Math.ceil(p.hp)} / ${p.maxHp}</p><p>Defesa: ${(p.defense * 100).toFixed(0)}%</p><p>Velocidade: ${(p.speedModifier * 100).toFixed(0)}%</p>`; if(p.characterType === 'wizard') { statsContainer.innerHTML += `<p>Dano Proj√©til: ${p.projectileDamage.toFixed(1)}</p>`; } statsContainer.innerHTML += `<p>Velocidade Ataque: ${(p.attackSpeedModifier * 100).toFixed(0)}%</p><p>Chance Cr√≠tica: ${(p.critChance * 100).toFixed(0)}%</p><p>Dano Cr√≠tico: ${(p.critDamageModifier * 100).toFixed(0)}%</p><p>Roubo de Vida: ${(p.lifesteal * 100).toFixed(1)}%</p>`; if (p.collectedUpgrades.length === 0) { upgradesContainer.innerHTML += '<p>No upgrades collected yet.</p>'; } else { p.collectedUpgrades.forEach(upgradeId => { const upgradeInfo = upgrades[upgradeId]; if (upgradeInfo) { const upgradeEl = document.createElement('div'); upgradeEl.className = `upgrade-item ${upgradeInfo.rarity}`; upgradeEl.textContent = upgradeInfo.name; upgradesContainer.appendChild(upgradeEl); } }); } }
                gameOver() { this.gameState = 'gameOver'; settings.set('totalDeaths', settings.get('totalDeaths') + 1); this.checkAchievements(); this.audio.stopAllMusic(); this.audio.play('playerDeath'); elements.scoreText.textContent = `Score: ${Math.floor(this.score)}`; if(Math.floor(this.score) > settings.get('highScore')) { settings.set('highScore', Math.floor(this.score)); elements.highScoreText.textContent = `NEW HIGH SCORE: ${Math.floor(this.score)}`; } else { elements.highScoreText.textContent = `High Score: ${settings.get('highScore')}`; } elements.gameOverScreen.classList.remove('hidden'); }
                levelUp() { this.gameState = 'levelUp'; this.rerollsUsedThisLevel = false; this.showUpgradeCards(); }
                createExplosion(x, y, size) { for(let i=0; i < size/2; i++) { this.particles.push(new Particle(this, x, y, `hsl(${Math.random() * 60}, 100%, 50%)`)); }}
                showUpgradeCards() { const cardContainer = elements.levelUpScreen.querySelector('.card-container'); cardContainer.innerHTML = ''; elements.rerollButton.disabled = this.rerollsUsedThisLevel; elements.rerollButton.textContent = this.rerollsUsedThisLevel ? 'Reroll Used' : 'Reroll'; let pool = Object.keys(upgrades); let choices = []; const availableUpgrades = pool.filter(id => !(id === 'Insight' && this.player.upgradeChoices >= 5) && !this.player.collectedUpgrades.includes(id)); for(let i=0; i < this.player.upgradeChoices; i++) { if(availableUpgrades.length === 0) break; let choiceIndex = Math.floor(Math.random() * availableUpgrades.length); let choice = availableUpgrades.splice(choiceIndex, 1)[0]; choices.push(choice); } choices.forEach(upgradeId => { const upgrade = upgrades[upgradeId]; const cardEl = document.createElement('div'); cardEl.className = `card ${upgrade.rarity}`; cardEl.dataset.upgradeId = upgradeId; let title = upgrade.name; cardEl.innerHTML = `<h3 class="card-title">${title}</h3><div class="card-icon">${upgrade.name.charAt(0)}</div><p class="card-description">${upgrade.description}</p>`; cardContainer.appendChild(cardEl); }); elements.levelUpScreen.classList.remove('hidden'); this.attachCardEvents(); }
                attachCardEvents() { const cards = elements.levelUpScreen.querySelectorAll('.card'); let isAnimating = false; const rerollHandler = () => { if(this.rerollsUsedThisLevel) return; this.rerollsUsedThisLevel = true; this.showUpgradeCards(); this.audio.play('click'); elements.rerollButton.removeEventListener('click', rerollHandler); }; elements.rerollButton.addEventListener('click', rerollHandler); cards.forEach((hoveredCard, hoveredIndex) => { hoveredCard.addEventListener('mouseenter', () => { if (isAnimating) return; cards.forEach((otherCard, otherIndex) => { if (hoveredIndex === otherIndex) otherCard.classList.add('hover-focus'); else if (otherIndex < hoveredIndex) otherCard.classList.add('look-right'); else otherCard.classList.add('look-left'); }); }); hoveredCard.addEventListener('mouseleave', () => { if (isAnimating) return; cards.forEach(card => card.classList.remove('hover-focus', 'look-left', 'look-right')); }); }); cards.forEach(clickedCard => { const clickHandler = () => { if (isAnimating) return; isAnimating = true; this.audio.play('cardPickup'); cards.forEach(c => c.classList.remove('hover-focus', 'look-left', 'look-right')); clickedCard.classList.add('selected'); cards.forEach(otherCard => { if (otherCard !== clickedCard) otherCard.classList.add('exploding'); }); this.player.applyUpgrade(clickedCard.dataset.upgradeId); setTimeout(() => { clickedCard.classList.add('exit-down'); setTimeout(() => { elements.levelUpScreen.classList.add('hidden'); cards.forEach(card => card.classList.remove('selected', 'exploding', 'exit-down')); this.gameState = this.bossActive ? 'bossWave' : 'playing'; this.lastTime = performance.now(); }, 1000); }, 1800); clickedCard.removeEventListener('click', clickHandler); elements.rerollButton.removeEventListener('click', rerollHandler); }; clickedCard.addEventListener('click', clickHandler); }); }
            }
        });
    </script>
</body>
</html>
