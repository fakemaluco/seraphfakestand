<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seraph's Last Stand</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=VT323&display=swap" rel="stylesheet">

    <style>
        @keyframes pulse-title { 0%, 100% { transform: scale(1); text-shadow: 4px 4px 0 #5a4a00, 0 0 30px rgba(255, 199, 0, 0.3); } 50% { transform: scale(1.05); text-shadow: 6px 6px 5px #5a4a00, 0 0 50px rgba(255, 199, 0, 0.6); } }
        @keyframes pulse-red { 0%, 100% { transform: scale(1); text-shadow: 2px 2px 0 #330000; } 50% { transform: scale(1.02); text-shadow: 3px 3px 3px #550000; } }
        @keyframes screen-shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-3px, 3px); } 50% { transform: translate(3px, -3px); } 75% { transform: translate(-3px, -3px); } }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }

        :root { --border-color: #FFF; --text-color: #FFF; --bg-color: #000; --dark-bg-color: #111; --accent-color: #e6b800; --border-radius: 0px; }

        body { background-color: var(--dark-bg-color); color: var(--text-color); font-family: 'VT323', monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; transition: background-image 0.5s ease; }
        #gameContainer { position: relative; width: 100%; max-width: 1280px; aspect-ratio: 16 / 9; background-color: #000; border: 4px solid var(--border-color); box-sizing: border-box; transition: transform 0.1s, border-radius 0.5s ease; border-radius: var(--border-radius); overflow: hidden; }
        #gameContainer.shake { animation: screen-shake 0.1s linear 1; }
        #gameCanvas { width: 100%; height: 100%; image-rendering: pixelated; position: absolute; top: 0; left: 0; z-index: 1; border-radius: var(--border-radius); cursor: url('cursor.png') 0 0, auto; }
        
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.8); transition: opacity 0.5s ease, backdrop-filter 0.5s ease; z-index: 10; text-align: center; border-radius: var(--border-radius); }
        .overlay.hidden { opacity: 0; pointer-events: none; }
        
        #preloader { z-index: 99; background-color: #000; cursor: pointer;}
        #preloader h1 { font-family: 'VT323', monospace; font-size: 3rem; color: #fff; animation: pulse-title 3s ease-in-out infinite; }

        #startScreen { background: radial-gradient(circle at 50% 50%, #1a1a1a, #000); }
        #startScreen h1 { font-family: 'Cinzel', serif; font-size: clamp(3rem, 10vw, 6rem); line-height: 1.1; margin: 0; color: var(--accent-color); animation: pulse-title 5s ease-in-out infinite; }
        .start-button { font-family: 'VT323', monospace; background: none; color: var(--text-color); cursor: pointer; border: 4px solid var(--border-color); box-shadow: 0 0 0 2px var(--bg-color), 0 0 0 4px var(--border-color); background-color: var(--bg-color); padding: 15px 50px; font-size: 2.5rem; transition: all 0.3s ease; border-radius: var(--border-radius); }
        .start-button:hover:not(:disabled) { color: var(--accent-color); border-color: var(--accent-color); box-shadow: 0 0 0 2px var(--bg-color), 0 0 0 4px var(--accent-color), 0 0 20px var(--accent-color); transform: scale(1.05); }
        .start-button:disabled { color: #666; border-color: #666; cursor: not-allowed; }
        
        .main-menu-container { display: flex; flex-direction: column; align-items: center; gap: 1.5rem; margin-top: 2rem; }
        #startButton { animation: float 3s ease-in-out infinite; }
        .sub-menu-buttons { display: flex; gap: 15px; }
        .sub-menu-buttons .start-button { font-size: 1.2rem; padding: 8px 20px; }

        #characterSelection { display: flex; gap: 2rem; margin: 1.5rem 0; }
        .char-card { border: 4px solid #555; padding: 1rem; cursor: pointer; transition: all 0.3s ease; text-align: center; }
        .char-card:hover { border-color: var(--text-color); transform: scale(1.05); }
        .char-card.selected { border-color: var(--accent-color); box-shadow: 0 0 15px var(--accent-color); transform: scale(1.1); }
        .char-card h4 { font-family: 'Cinzel', serif; margin: 10px 0 0 0; font-size: 1.2rem; }
        .char-preview { width: 64px; height: 128px; image-rendering: pixelated; background-color: #333; margin: 0 auto; display: flex; justify-content: center; align-items: center; font-size: 3rem; }
        .char-preview img { width: 100%; height: 100%; object-fit: contain; }

        #gameOverScreen { background-color: rgba(30, 0, 0, 0.8); }
        #gameOverScreen h2 { font-family: 'Cinzel', serif; font-size: 6rem; color: #d44; margin: 0; animation: pulse-red 2s ease-in-out infinite; }
        #gameOverScreen p { font-size: 2.5rem; margin: 20px 0; }
        #highScoreText { color: var(--accent-color); font-size: 1.8rem; }
        #retryButton { font-family: 'VT323', monospace; font-size: 2rem; color: #ccc; border: 4px solid #ccc; background-color: #222; padding: 10px 40px; cursor: pointer; transition: all 0.2s ease; border-radius: var(--border-radius); }
        #retryButton:hover { color: #fff; border-color: #fff; background-color: #444; transform: scale(1.05); }
        
        #hud { position: absolute; top: 20px; left: 20px; z-index: 5; width: 30%; max-width: 350px; font-size: 1.2rem; display: flex; flex-direction: column; gap: 5px; background: rgba(0,0,0,0.3); padding: 10px; border: 2px solid rgba(255,255,255,0.2); border-radius: var(--border-radius); transition: all 0.5s ease; }
        .hud-item { display: flex; align-items: center; gap: 10px; }
        .bar-container { flex-grow: 1; height: 20px; background-color: rgba(0, 0, 0, 0.4); border: 2px solid #fff; box-sizing: border-box; border-radius: var(--border-radius); overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.3s ease-out; }
        #hp-bar { background-color: #c0392b; } #exp-bar { background-color: #2980b9; }

        #pauseScreen .pause-content { display: flex; justify-content: space-around; width: 80%; max-width: 900px; margin-top: 1rem; align-items: flex-start; }
        .pause-column { background-color: rgba(0,0,0,0.5); border: 2px solid #555; padding: 1.5rem; width: 45%; border-radius: var(--border-radius); }
        .pause-column h3 { font-family: 'Cinzel', serif; font-size: 1.8rem; margin-top: 0; margin-bottom: 1rem; color: var(--accent-color); text-shadow: 2px 2px #333; }
        #pauseStats p { font-size: 1.1rem; margin: 5px 0; text-align: left; }
        #pauseUpgrades .upgrade-item { font-size: 1rem; padding: 5px 10px; margin-bottom: 5px; border-left: 5px solid; text-align: left; }
        .upgrade-item.common { border-color: #ccc; color: #ccc; } .upgrade-item.uncommon { border-color: #55ff55; color: #55ff55; } .upgrade-item.rare { border-color: #8855ff; color: #8855ff; }

        #levelUpScreen { backdrop-filter: blur(5px); }
        #levelUpScreen h2 { font-family: 'Cinzel', serif; font-size: 3rem; margin-bottom: 2rem; color: #fff; text-shadow: 3px 3px #333; }
        .card-container { display: flex; gap: 20px; perspective: 1200px; margin-bottom: 2rem; }
        #rerollButton { font-size: 1.5rem; padding: 10px 30px; }

        .card { width: 170px; height: 250px; background-color: #000; border: 3px solid #444; cursor: pointer; position: relative; padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.6s ease, border-color 0.4s ease; transform-style: preserve-3d; border-radius: var(--border-radius); }
        .card-title { font-family: 'Cinzel', serif; margin: 0 0 10px 0; font-size: 1.1rem; color: #fff; }
        .card.common .card-title { color: #fff; } .card.uncommon .card-title { color: #55ff55; } .card.rare .card-title { color: #8855ff; }
        .card-icon { width: 90px; height: 90px; border: 3px solid #ccc; margin-bottom: 15px; display: flex; justify-content: center; align-items: center; background-color: #111; font-size: 3rem; color: white; border-radius: var(--border-radius); }
        .card-description { color: #ddd; text-align: center; font-size: 0.9rem; line-height: 1.3; }
        .card.hover-focus { transform: translateY(-25px) scale(1.1); border-color: #66ff66; z-index: 101; }
        .card.look-left { transform: rotateY(-20deg) scale(0.95); } .card.look-right { transform: rotateY(20deg) scale(0.95); }
        .card.selected { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1.25); border-color: #ffa500; z-index: 100; }
        .card.exploding { opacity: 0; pointer-events: none; }
        .card.exploding:nth-of-type(odd) { transform: translate(-60vw, -110vh) rotate(-480deg) scale(0); }
        .card.exploding:nth-of-type(even) { transform: translate(60vw, 110vh) rotate(480deg) scale(0); }
        .card.exploding:nth-of-type(3n) { transform: translate(0, 120vh) rotate(360deg) scale(0); }
        .card.selected.exit-down { transition-timing-function: cubic-bezier(0.16, 1, 0.3, 1); transform: translate(-50%, 150vh) scale(1.25); }

        #settingsScreen .settings-container, #achievementsScreen .achievements-container, #creditsScreen .settings-container { display: flex; flex-direction: column; gap: 1.5rem; background: rgba(0,0,0,0.6); border: 2px solid #555; padding: 2rem; width: 60%; max-width: 700px; border-radius: var(--border-radius); }
        .setting-item { display: flex; justify-content: space-between; align-items: center; font-size: 1.5rem; }
        .setting-item input[type="range"], .setting-item input[type="number"] { width: 50%; }
        .setting-item input[type="checkbox"] { width: 25px; height: 25px; cursor: pointer; }
        .setting-item button { font-size: 1.2rem; padding: 8px 15px; width: 50%; }

        #achievementsScreen .achievements-container { max-height: 70vh; overflow-y: auto; }
        .achievement-item { display: flex; align-items: center; padding: 10px; background-color: #222; margin-bottom: 10px; border-left: 5px solid #555; transition: all 0.3s ease; border-radius: var(--border-radius); }
        .achievement-item.unlocked { background-color: #4a4a2a; border-left-color: var(--accent-color); }
        .achievement-icon { font-size: 2.5rem; width: 50px; text-align: center; margin-right: 15px; }
        .achievement-details { text-align: left; }
        .achievement-details h4 { margin: 0; font-size: 1.2rem; }
        .achievement-details p { margin: 0; font-size: 1rem; color: #aaa; }
        .achievement-item.unlocked .achievement-details h4 { color: var(--accent-color); }
        .achievement-item.unlocked .achievement-details p { color: #eee; }

        body.frutiger-aero-active { background-image: url('background.png'); background-size: cover; background-position: center; }
        body.frutiger-aero-active { --border-radius: 15px; }
        body.frutiger-aero-active #hud { border-style: outset; border-color: rgba(255, 255, 255, 0.8); background: linear-gradient(145deg, rgba(80,150,255,0.4), rgba(40,100,220,0.5)); backdrop-filter: blur(5px); }


        #debugPanel { flex-direction: column; gap: 1rem; margin-top: 1.5rem; border-top: 2px solid #555; padding-top: 1.5rem; }
        #debugPanel h3 { color: #ff4757; margin: 0 0 1rem 0; font-size: 1.5rem; }
        .hidden { display: none !important; }

    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud" class="hidden"><div class="hud-item"><span id="hpText">HP: 100/100</span><div class="bar-container"><div id="hp-bar" class="bar-fill"></div></div></div><div class="hud-item"><span id="expText">LVL: 1</span><div class="bar-container"><div id="exp-bar" class="bar-fill"></div></div></div></div>
        <canvas id="gameCanvas"></canvas>
        <div id="preloader" class="overlay"><h1 id="preloaderText">LOADING...</h1></div>
        <div id="startScreen" class="overlay hidden">
            <h1>SERAPH'S<br>LAST STAND</h1>
            <p>CHOOSE YOUR HERO</p>
            <div id="characterSelection">
                <div class="char-card" data-char="wizard">
                    <div class="char-preview"><img id="wizardPreview" alt="Wizard Character"></div>
                    <h4>Seraph (Mage)</h4>
                </div>
                <div class="char-card" data-char="gladiator">
                    <div class="char-preview"><img id="gladiatorPreview" alt="Gladiator Character"></div>
                    <h4>Gladiator</h4>
                </div>
            </div>
            <div class="main-menu-container">
                <button id="startButton" class="start-button" disabled>START</button>
                <div class="sub-menu-buttons">
                    <button id="achievementsButtonMain" class="start-button">Achievements</button>
                    <button id="settingsButtonMain" class="start-button">Settings</button>
                    <button id="creditsButton" class="start-button">Credits</button>
                </div>
            </div>
        </div>
        <div id="pauseScreen" class="overlay hidden">
            <h1>PAUSED</h1><div class="pause-content"><div class="pause-column" id="pauseStats"><h3>Player Stats</h3></div><div class="pause-column" id="pauseUpgrades"><h3>Current Upgrades</h3></div></div>
            <button id="continueButton" class="start-button overlay-menu-button">Continue</button><button id="settingsButtonPause" class="start-button overlay-menu-button" style="font-size: 1.5rem; padding: 10px 30px;">Settings</button><button id="newGameButton" class="start-button overlay-menu-button">New Game</button>
        </div>
        <div id="levelUpScreen" class="overlay hidden"><h2>Choose a Card</h2><div class="card-container"></div><button id="rerollButton" class="start-button">Reroll</button></div>
        <div id="gameOverScreen" class="overlay hidden"><h2>GAME OVER</h2><p id="scoreText">Score: 0</p><p id="highScoreText">High Score: 0</p><button id="retryButton">Retry</button></div>
        <div id="settingsScreen" class="overlay hidden">
            <h1>Settings</h1><div class="settings-container">
                <div class="setting-item"><label for="musicVolume">Music Volume</label><input type="range" id="musicVolume" min="0" max="1" step="0.05"></div>
                <div class="setting-item"><label for="sfxVolume">SFX Volume</label><input type="range" id="sfxVolume" min="0" max="1" step="0.05"></div>
                <div class="setting-item"><label for="particleDensity">Particle Density</label><input type="range" id="particleDensity" min="0" max="1" step="0.1"></div>
                <hr>
                <div class="setting-item"><label for="autoAttackCheckbox">Auto-Attack</label><input type="checkbox" id="autoAttackCheckbox"></div>
                <div class="setting-item"><label for="showDamageNumbersCheckbox">Show Damage</label><input type="checkbox" id="showDamageNumbersCheckbox"></div>
                <div class="setting-item"><label for="screenShakeCheckbox">Screen Shake</label><input type="checkbox" id="screenShakeCheckbox"></div>
                <div class="setting-item"><label for="cameraModeBtn">Camera Mode</label><button id="cameraModeBtn" class="start-button">Follow</button></div>
                <hr>
                <div class="setting-item"><label for="bloomEffectCheckbox">Bloom Effect</label><input type="checkbox" id="bloomEffectCheckbox"></div>
                <div class="setting-item"><label for="frutigerAeroCheckbox">Frutiger Aero</label><input type="checkbox" id="frutigerAeroCheckbox"></div>
                <div class="setting-item"><label for="fullscreenBtn">Fullscreen</label><button id="fullscreenBtn" class="start-button">Enter</button></div>
                
                <div id="debugPanel" class="hidden">
                <h3>- DEBUG PANEL -</h3>
                <div class="setting-item"><label for="debugLevel">Player Level</label><input type="number" id="debugLevel" min="1" max="99"></div>
                <div class="setting-item"><label for="debugDamage">Base Damage</label><input type="number" id="debugDamage" min="1" max="500"></div>
                <div class="setting-item"><label for="debugMaxHp">Max HP</label><input type="number" id="debugMaxHp" min="10" max="1000"></div>
                <div class="setting-item"><button id="godModeBtn" class="start-button">God Mode (OFF)</button></div>
                </div>
            </div>
            <button id="closeSettingsButton" class="start-button overlay-menu-button" style="margin-top: 2rem;">Back</button>
        </div>
        <div id="achievementsScreen" class="overlay hidden">
            <h1>Achievements</h1><div class="achievements-container"></div>
            <button id="closeAchievementsButton" class="start-button overlay-menu-button" style="margin-top: 2rem;">Back</button>
        </div>
        <div id="creditsScreen" class="overlay hidden">
            <h1>Credits</h1>
            <div class="settings-container" style="text-align: center; font-size: 1.2rem; line-height: 1.6;">
                <p>A Game By: You!</p>
                <p>Inspired by Vampire Survivors & other great games.</p>
                <p>Assets from various open-source creators.</p>
                <p>Font 'Cinzel' & 'VT323' from Google Fonts.</p>
                <br>
                <p style="color: var(--accent-color);">Special thanks to the developer who implemented this feature map!</p>
            </div>
            <button id="closeCreditsButton" class="start-button overlay-menu-button" style="margin-top: 2rem;">Back</button>
        </div>
    </div>

    <script>
        /*
         * DEVELOPER NOTE (BUG FIX):
         * The previous version had a syntax error (a stray parenthesis) that caused an
         * infinite loading screen. This has been corrected. All recent features, including
         * the rebalanced first boss, remain intact.
        */
        document.addEventListener('DOMContentLoaded', () => {
            const elements = { hud: document.getElementById('hud'), gameContainer: document.getElementById('gameContainer'), canvas: document.getElementById('gameCanvas'), preloader: document.getElementById('preloader'), preloaderText: document.getElementById('preloaderText'), startScreen: document.getElementById('startScreen'), startButton: document.getElementById('startButton'), pauseScreen: document.getElementById('pauseScreen'), continueButton: document.getElementById('continueButton'), newGameButton: document.getElementById('newGameButton'), levelUpScreen: document.getElementById('levelUpScreen'), gameOverScreen: document.getElementById('gameOverScreen'), retryButton: document.getElementById('retryButton'), scoreText: document.getElementById('scoreText'), highScoreText: document.getElementById('highScoreText'), hpBar: document.getElementById('hp-bar'), expBar: document.getElementById('exp-bar'), hpText: document.getElementById('hpText'), expText: document.getElementById('expText'), rerollButton: document.getElementById('rerollButton'), settingsScreen: document.getElementById('settingsScreen'), settingsButtonMain: document.getElementById('settingsButtonMain'), settingsButtonPause: document.getElementById('settingsButtonPause'), closeSettingsButton: document.getElementById('closeSettingsButton'), musicVolumeSlider: document.getElementById('musicVolume'), sfxVolumeSlider: document.getElementById('sfxVolume'), cameraModeBtn: document.getElementById('cameraModeBtn'), showDamageNumbersCheckbox: document.getElementById('showDamageNumbersCheckbox'), screenShakeCheckbox: document.getElementById('screenShakeCheckbox'), autoAttackCheckbox: document.getElementById('autoAttackCheckbox'), particleDensitySlider: document.getElementById('particleDensity'), bloomEffectCheckbox: document.getElementById('bloomEffectCheckbox'), frutigerAeroCheckbox: document.getElementById('frutigerAeroCheckbox'), achievementsScreen: document.getElementById('achievementsScreen'), achievementsButtonMain: document.getElementById('achievementsButtonMain'), closeAchievementsButton: document.getElementById('closeAchievementsButton'), creditsScreen: document.getElementById('creditsScreen'), creditsButton: document.getElementById('creditsButton'), closeCreditsButton: document.getElementById('closeCreditsButton'), fullscreenBtn: document.getElementById('fullscreenBtn'), debugPanel: document.getElementById('debugPanel'), debugLevel: document.getElementById('debugLevel'), debugDamage: document.getElementById('debugDamage'), debugMaxHp: document.getElementById('debugMaxHp'), godModeBtn: document.getElementById('godModeBtn'), wizardPreview: document.getElementById('wizardPreview'), gladiatorPreview: document.getElementById('gladiatorPreview'), characterSelection: document.getElementById('characterSelection') };
            const ctx = elements.canvas.getContext('2d'); let animationFrameId; let game; let globalAudioManager; let debugUnlocked = false; let selectedCharacter = null;

            class SettingsManager { constructor() { this.defaults = { musicVolume: 0.3, sfxVolume: 0.5, showDamageNumbers: true, bloom: true, frutigerAero: false, highScore: 0, totalKills: 0, totalDeaths: 0, unlockedAchievements: [], cameraMode: 'follow', screenShake: true, particleDensity: 1.0, autoAttack: false }; this.settings = this.load(); } load() { const saved = localStorage.getItem('seraphsLastStandSettings'); return saved ? { ...this.defaults, ...JSON.parse(saved) } : this.defaults; } save() { localStorage.setItem('seraphsLastStandSettings', JSON.stringify(this.settings)); } get(key) { return this.settings[key]; } set(key, value) { this.settings[key] = value; this.save(); } }
            const settings = new SettingsManager();
            
            const achievements = { 'kill_10': { name: 'Novice Slayer', description: 'Defeat 10 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 10 }, 'kill_100': { name: 'Adept Slayer', description: 'Defeat 100 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 100 }, 'kill_500': { name: 'Master Slayer', description: 'Defeat 500 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 500 }, 'death_1': { name: 'First of Many', description: 'Die for the first time.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 1 }, 'death_10': { name: 'Persistent', description: 'Die 10 times.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 10 }, 'rare_card': { name: 'A Rare Find', description: 'Obtain a Rare upgrade.', icon: 'üíé', check: (g) => Object.keys(g.player.upgrades).some(id => upgrades[id]?.rarity === 'rare') }, 'frutiger_aero': { name: 'Sonho do Andrezitos?', description: 'Discover a more... glossy reality.', icon: 'üíß', check: () => settings.get('frutigerAero') } };
            const assetPaths = { images: { player: 'mago.png', gladiator: 'gladiator.png', enemy: 'inimigo.png', eye: 'eye.png', demon: 'demon.png', boss1: 'boss1.png', boss2: 'boss2.png' }, sounds: { soundtrack: 'soundtrack.mp3', menu: 'menu.mp3', bullet: 'bullet.mp3', jump: 'pulo.mp3', playerDamage: 'playerdamage.mp3', playerDeath: 'playerdeathsound.mp3', enemyDeath: 'enemiedeathsound.mp3', cardPickup: 'cardpickup.mp3', click: 'click.mp3', key: 'key.mp3', boss1: 'boss1.mp3', boss2: 'boss2.mp3', levelUp: 'levelup.mp3', reroll: 'reroll.mp3', enemyShoot: 'enemyshoot.mp3', shieldBlock: 'shieldblock.mp3', dash: 'dash.mp3', thunderStrike: 'thunderstrike.mp3', meleeSwing: 'meleeswing.mp3', achievement: 'achievement.mp3' } };
            
            class AssetLoader { constructor(paths) {this.paths = paths; this.images = {}; this.sounds = {};} load(onProgress) {const imagePromises = Object.entries(this.paths.images).map(([key, path]) => new Promise((resolve) => {const img = new Image(); img.src = path; img.onload = () => {this.images[key] = img; onProgress(); resolve();}; img.onerror = () => {console.warn(`Could not load image: ${path}`); onProgress(); resolve();};})); const soundPromises = Object.entries(this.paths.sounds).map(([key, path]) => new Promise((resolve) => {const audio = new Audio(); const canPlayHandler = () => {this.sounds[key] = audio; onProgress(); audio.removeEventListener('canplaythrough', canPlayHandler); resolve();}; audio.addEventListener('canplaythrough', canPlayHandler); audio.onerror = () => {console.warn(`Could not load sound: ${path}`); onProgress(); resolve();}; audio.src = path; audio.load();})); return Promise.all([...imagePromises, ...soundPromises]);}}
            class AudioManager { constructor(sounds) { this.sounds = sounds; this.currentMusic = null; } play(soundName, volumeMultiplier = 1) { if (this.sounds[soundName]) { const sound = this.sounds[soundName].cloneNode(); sound.volume = settings.get('sfxVolume') * volumeMultiplier; sound.play().catch(e => {}); } } startMusic(track) { this.stopAllMusic(); if (this.sounds[track]) { this.currentMusic = this.sounds[track]; this.currentMusic.loop = true; this.currentMusic.volume = settings.get('musicVolume'); this.currentMusic.play().catch(e => {}); } } stopAllMusic() { if(this.currentMusic) { this.currentMusic.pause(); this.currentMusic.currentTime = 0; } this.currentMusic = null; } updateMusicVolume() { if(this.currentMusic) { this.currentMusic.volume = settings.get('musicVolume'); } } }
            
            function resizeCanvas() { const containerRect = elements.gameContainer.getBoundingClientRect(); elements.canvas.width = containerRect.width; elements.canvas.height = containerRect.height; if (game) { game.width = elements.canvas.width; game.height = elements.canvas.height; game.createStars(); } }
            
            const assetLoader = new AssetLoader(assetPaths);
            const totalAssets = Object.keys(assetPaths.images).length + Object.keys(assetPaths.sounds).length; let loadedAssets = 0;
            assetLoader.load(() => { loadedAssets++; elements.preloaderText.textContent = `LOADING... ${Math.round((loadedAssets / totalAssets) * 100)}%`; }).then(() => {
                globalAudioManager = new AudioManager(assetLoader.sounds);
                elements.preloaderText.textContent = "CLICK TO START";
                if(assetLoader.images.player) elements.wizardPreview.src = assetLoader.images.player.src;
                if(assetLoader.images.gladiator) elements.gladiatorPreview.src = assetLoader.images.gladiator.src;
                elements.preloader.addEventListener('click', () => {
                    elements.preloader.classList.add('hidden');
                    elements.startScreen.classList.remove('hidden');
                    globalAudioManager.startMusic('menu');
                }, { once: true });
            });

            function setupCharacterSelection() {
                elements.characterSelection.addEventListener('click', (e) => {
                    const card = e.target.closest('.char-card');
                    if (!card) return;
                    selectedCharacter = card.dataset.char;
                    document.querySelectorAll('.char-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                    elements.startButton.disabled = false;
                    globalAudioManager.play('click', 0.5);
                });
            }

            function startGame() { if (!selectedCharacter) return; globalAudioManager.play('click'); elements.startScreen.classList.add('hidden'); elements.hud.classList.remove('hidden'); elements.gameOverScreen.classList.add('hidden'); game = new Game(elements.canvas.width, elements.canvas.height, assetLoader.images, globalAudioManager, selectedCharacter); if(animationFrameId) cancelAnimationFrame(animationFrameId); gameLoop(); }
            function gameLoop(timestamp) { if(game && game.gameState !== 'gameOver') { if (game.gameState === 'playing' || game.gameState === 'bossWave' || game.gameState === 'cutscene') { ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height); game.update(timestamp); game.draw(ctx); } animationFrameId = requestAnimationFrame(gameLoop); } }
            
            function applyFrutigerAero() { document.body.classList.toggle('frutiger-aero-active', settings.get('frutigerAero')); }
            function setupSettingsUI() { elements.musicVolumeSlider.value = settings.get('musicVolume'); elements.sfxVolumeSlider.value = settings.get('sfxVolume'); elements.particleDensitySlider.value = settings.get('particleDensity'); elements.showDamageNumbersCheckbox.checked = settings.get('showDamageNumbers'); elements.screenShakeCheckbox.checked = settings.get('screenShake'); elements.autoAttackCheckbox.checked = settings.get('autoAttack'); elements.bloomEffectCheckbox.checked = settings.get('bloom'); elements.frutigerAeroCheckbox.checked = settings.get('frutigerAero'); elements.cameraModeBtn.textContent = settings.get('cameraMode') === 'follow' ? 'Follow' : 'Static Arena'; const toggleSettings = () => { if(globalAudioManager) globalAudioManager.play('click'); elements.settingsScreen.classList.toggle('hidden'); if(debugUnlocked) elements.debugPanel.classList.remove('hidden');}; elements.settingsButtonMain.addEventListener('click', toggleSettings); elements.settingsButtonPause.addEventListener('click', toggleSettings); elements.closeSettingsButton.addEventListener('click', toggleSettings); elements.musicVolumeSlider.addEventListener('input', (e) => { settings.set('musicVolume', parseFloat(e.target.value)); if(globalAudioManager) globalAudioManager.updateMusicVolume(); }); elements.sfxVolumeSlider.addEventListener('input', (e) => settings.set('sfxVolume', parseFloat(e.target.value))); elements.particleDensitySlider.addEventListener('input', (e) => settings.set('particleDensity', parseFloat(e.target.value))); elements.showDamageNumbersCheckbox.addEventListener('change', (e) => settings.set('showDamageNumbers', e.target.checked)); elements.screenShakeCheckbox.addEventListener('change', (e) => settings.set('screenShake', e.target.checked)); elements.autoAttackCheckbox.addEventListener('change', (e) => settings.set('autoAttack', e.target.checked)); elements.bloomEffectCheckbox.addEventListener('change', (e) => settings.set('bloom', e.target.checked)); elements.frutigerAeroCheckbox.addEventListener('change', (e) => { settings.set('frutigerAero', e.target.checked); applyFrutigerAero(); if(game) game.checkAchievements(); }); elements.cameraModeBtn.addEventListener('click', () => { const newMode = settings.get('cameraMode') === 'follow' ? 'static' : 'follow'; settings.set('cameraMode', newMode); elements.cameraModeBtn.textContent = newMode === 'follow' ? 'Follow' : 'Static Arena'; }); elements.fullscreenBtn.addEventListener('click', () => { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`)); } else { document.exitFullscreen(); } }); applyFrutigerAero(); }
            function setupAchievementsUI() { const toggleAchievements = () => { globalAudioManager.play('click'); elements.achievementsScreen.classList.toggle('hidden'); }; elements.achievementsButtonMain.addEventListener('click', () => { populateAchievementsScreen(); toggleAchievements(); }); elements.closeAchievementsButton.addEventListener('click', toggleAchievements); }
            function setupCreditsUI() { const toggleCredits = () => { globalAudioManager.play('click'); elements.creditsScreen.classList.toggle('hidden'); }; elements.creditsButton.addEventListener('click', toggleCredits); elements.closeCreditsButton.addEventListener('click', toggleCredits); }
            function populateAchievementsScreen() { const container = elements.achievementsScreen.querySelector('.achievements-container'); container.innerHTML = ''; const unlocked = settings.get('unlockedAchievements'); for (const id in achievements) { const ach = achievements[id]; const isUnlocked = unlocked.includes(id); container.innerHTML += `<div class="achievement-item ${isUnlocked ? 'unlocked' : ''}"><span class="achievement-icon">${isUnlocked ? ach.icon : '‚ùì'}</span><div class="achievement-details"><h4>${isUnlocked ? ach.name : '??????'}</h4><p>${isUnlocked ? ach.description : 'Keep playing to unlock!'}</p></div></div>`; } }
            function setupDebugTools() { let keySequence = []; const secretCode = ['KeyA', 'KeyN', 'KeyD', 'KeyR', 'KeyE']; window.addEventListener('keydown', (e) => { if (debugUnlocked) return; keySequence.push(e.code); keySequence.splice(-secretCode.length - 1, keySequence.length - secretCode.length); if (keySequence.join('') === secretCode.join('')) { debugUnlocked = true; console.log("Debug Mode Unlocked!"); if(!elements.settingsScreen.classList.contains('hidden')) elements.debugPanel.classList.remove('hidden');} }); elements.debugLevel.addEventListener('change', e => { if (game?.player) { game.player.level = parseInt(e.target.value) || 1; game.player.exp = 0; game.updateHUD(); }}); elements.debugDamage.addEventListener('change', e => { if (game?.player) game.player.baseDamage = parseInt(e.target.value) || 5; }); elements.debugMaxHp.addEventListener('change', e => { if (game?.player) { game.player.maxHp = parseInt(e.target.value) || 100; game.player.hp = game.player.maxHp; game.updateHUD(); }}); elements.godModeBtn.addEventListener('click', () => { if(game?.player) { game.player.isInvincible = !game.player.isInvincible; elements.godModeBtn.textContent = `God Mode (${game.player.isInvincible ? 'ON' : 'OFF'})`; } }); }
            
            setupCharacterSelection(); setupSettingsUI(); setupAchievementsUI(); setupCreditsUI(); setupDebugTools();
            elements.startButton.addEventListener('click', startGame); elements.retryButton.addEventListener('click', () => { globalAudioManager.play('click'); location.reload(); }); elements.continueButton.addEventListener('click', () => game.togglePause()); elements.newGameButton.addEventListener('click', () => { if(game) game.audio.play('click'); location.reload(); });
            resizeCanvas();

            const upgrades = { 'Vitality': { name: 'Vitality', rarity: 'common', maxLevel: 5, getDescription: (level) => `Max HP +${25 * level}.`, effect: (p) => { p.maxHp += 25; p.hp += 25; } }, 'Power': { name: 'Power', rarity: 'common', maxLevel: 5, getDescription: (level) => `Base Damage +${3 * level}.`, effect: (p) => { p.baseDamage += 3; } }, 'Haste': { name: 'Haste', rarity: 'common', maxLevel: 5, getDescription: (level) => `Attack Speed +${10 * level}%.`, effect: (p) => { p.attackSpeedModifier += 0.10; } }, 'Swiftness': { name: 'Swiftness', rarity: 'common', maxLevel: 5, getDescription: (level) => `Movement Speed +${15 * level}%.`, effect: (p) => { p.speedModifier += 0.15; } }, 'Aegis': { name: 'Aegis', rarity: 'common', maxLevel: 3, getDescription: (level) => `Defense +${5 * level}% and flat 1 damage reduction.`, effect: (p) => { p.defense += 0.05; p.flatDamageReduction = (p.flatDamageReduction || 0) + 1; } }, 'Crit_Chance': { name: 'Crit Chance', rarity: 'common', maxLevel: 4, getDescription: (level) => `Critical Chance +${5 * level}%.`, effect: (p) => { p.critChance += 0.05; } }, 'Crit_Damage': { name: 'Crit Damage', rarity: 'uncommon', maxLevel: 1, getDescription: () => 'Critical hits deal +50% damage.', effect: (p) => { p.critDamageModifier += 0.5; } }, 'Leech': { name: 'Leech', rarity: 'uncommon', maxLevel: 1, getDescription: () => 'Heal for 3% of damage dealt.', effect: (p) => { p.lifesteal += 0.03; } }, 'Multi_Shot': { name: 'Multi-Shot', rarity: 'uncommon', maxLevel: 1, getDescription: () => 'Fire an additional projectile.', effect: (p) => { p.projectileCount += 1; } }, 'Acrobatics': { name: 'Acrobatics', rarity: 'uncommon', maxLevel: 1, getDescription: () => 'Gain an additional jump.', effect: (p) => { p.maxJumps += 1; } }, 'Healing_Orbs': { name: 'Healing Orbs', rarity: 'uncommon', maxLevel: 1, getDescription: () => 'Enemies have a chance to drop healing orbs.', effect: (p) => { p.special.healingOrbChance = 0.05; } }, 'Piercing_Shots': { name: 'Piercing Shots', rarity: 'uncommon', maxLevel: 1, getDescription: () => 'Projectiles pierce 1 additional enemy.', effect: (p) => { p.pierceCount += 1; } }, 'Frost_Bolt': { name: 'Frost Bolt', rarity: 'uncommon', maxLevel: 1, getDescription: () => 'Projectiles briefly freeze enemies on hit.', effect: (p) => { p.special.frostBolt = true; } }, 'Thunderbolt': { name: 'Thunderbolt', rarity: 'rare', maxLevel: 1, getDescription: () => 'Calls a thunderbolt on a random enemy every 5s.', effect: (p) => { p.special.thunderbolt = { interval: 5000, timer: 5000 }; } }, 'Blink': { name: 'Blink', rarity: 'rare', maxLevel: 1, getDescription: () => 'SHIFT to dash. Pass through enemies while dashing.', effect: (p) => { p.special.blink = { ready: true, cooldown: 3000, timer: 0 }; } }, 'Barrier': { name: 'Barrier', rarity: 'rare', maxLevel: 1, getDescription: () => 'Blocks one instance of damage every 10s.', effect: (p) => { p.special.barrier = { ready: true, cooldown: 10000, timer: 10000 }; } }, 'Insight': { name: 'Insight', rarity: 'rare', maxLevel: 1, getDescription: () => 'Get +1 card choice on level up.', effect: (p) => { p.upgradeChoices = Math.min(5, p.upgradeChoices + 1); } }, 'Ground_Slam': { name: 'Ground Slam', rarity: 'rare', maxLevel: 1, getDescription: () => 'Landing after a long fall creates a shockwave.', effect: (p) => { p.special.groundSlam = true; } }, 'Chain_Lightning': { name: 'Chain Lightning', rarity: 'rare', maxLevel: 1, getDescription: () => 'Your projectiles have a 25% chance to chain to a nearby enemy.', effect: (p) => { p.special.chainLightning = 0.25; } }, 'Fragmentation': { name: 'Fragmentation', rarity: 'rare', maxLevel: 1, getDescription: () => 'Slain enemies explode into 3 damaging fragments.', effect: (p) => { p.special.fragmentation = 3; } } };

            const inputHandler = { keys: new Set(), mouse: { x: 0, y: 0, down: false }, init() { window.addEventListener('keydown', e => { this.keys.add(e.code); if (e.code === 'Escape' && game && (game.gameState === 'playing' || game.gameState === 'paused' || game.gameState === 'bossWave')) game.togglePause(); if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') if(game && game.player.special.blink?.ready) game.player.dash(); }); window.addEventListener('keyup', e => this.keys.delete(e.code)); elements.canvas.addEventListener('mousemove', e => { const rect = elements.canvas.getBoundingClientRect(); this.mouse.x = e.clientX - rect.left; this.mouse.y = e.clientY - rect.top; }); elements.canvas.addEventListener('mousedown', () => this.mouse.down = true); elements.canvas.addEventListener('mouseup', () => this.mouse.down = false); } };
            inputHandler.init();
            
            class Player { constructor(game, characterType) { this.game = game; this.characterType = characterType; this.width = 32; this.height = 64; this.x = this.game.width / 2; this.y = this.game.height - this.height - 40; this.vx = 0; this.vy = 0; this.onGround = false; this.jumpsLeft = 2; this.maxJumps = 2; this.image = this.game.assets[this.characterType === 'gladiator' ? 'gladiator' : 'player']; this.weaponAngle = 0; this.weaponLength = 40; this.level = 1; this.exp = 0; this.expToNextLevel = 10; this.isInvincible = false; this.invincibilityDuration = 500; this.invincibilityTimer = 0; this.isDashing = false; this.fallTime = 0; this.upgrades = {}; this.special = {}; this.statusEffects = { burn: { active: false, duration: 0, damagePerSecond: 0 }, silenced: { active: false, duration: 0 } }; this.initStats(); } initStats() { this.speedModifier = 1; this.jumpModifier = 1; this.attackSpeedModifier = 1; this.critChance = 0.05; this.critDamageModifier = 1.5; this.lifesteal = 0; this.pierceCount = 0; this.projectileCount = 1; this.shootCooldown = 500; this.lastShotTime = 0; this.upgradeChoices = 3; this.flatDamageReduction = 0; this.defense = 0; if (this.characterType === 'wizard') { this.maxHp = 100; this.baseDamage = 8; this.special.shotCounter = 0; } else if (this.characterType === 'gladiator') { this.maxHp = 150; this.baseDamage = 12; this.defense = 0.05; this.shootCooldown = 700; this.special.killCounter = 0; this.special.bonusHp = 0; } this.hp = this.maxHp; } draw(ctx) { ctx.save(); if(this.special.blink) { const blink = this.special.blink; if(!blink.ready) { ctx.strokeStyle = 'cyan'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.height/2 + 8, -Math.PI/2, -Math.PI/2 + (Math.PI*2) * (1 - blink.timer / blink.cooldown)); ctx.stroke(); } } ctx.translate(this.x + this.width / 2, this.y + this.height / 2 - 10); ctx.rotate(this.weaponAngle); if(this.characterType === 'wizard') { ctx.fillStyle = '#654321'; ctx.fillRect(0, -2, this.weaponLength, 4); let orbColor = (this.special.shotCounter === 4) ? '#FFD700' : '#00FFFF'; if (settings.get('bloom')) { ctx.shadowBlur = 15; ctx.shadowColor = orbColor; } ctx.fillStyle = orbColor; ctx.beginPath(); ctx.arc(this.weaponLength, 0, 8, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); if (this.statusEffects.burn.active) { for(let i=0; i < 3 * settings.get('particleDensity'); i++) this.game.particles.push(new Particle(this.game, this.x + Math.random() * this.width, this.y + Math.random() * this.height, 'orange', 0.5)); } ctx.globalAlpha = (this.isInvincible || this.isDashing) ? 0.5 : 1.0; if(this.image?.complete && this.image.width > 0) { ctx.drawImage(this.image, this.x, this.y, this.width, this.height); } else { ctx.fillStyle = this.characterType === 'gladiator' ? '#6c757d' : '#8a2be2'; ctx.fillRect(this.x, this.y, this.width, this.height); } ctx.globalAlpha = 1.0; if (this.special.barrier?.ready) { if(settings.get('bloom')) { ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(100, 150, 255, 0.8)'; } ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.height/2 + 5, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur=0; } if (this.statusEffects.silenced.active) { ctx.fillStyle = 'white'; ctx.font = "30px VT323"; ctx.textAlign = 'center'; ctx.fillText('...', this.x + this.width / 2, this.y - 10); } } update(input, deltaTime) { if(this.special.blink && !this.special.blink.ready) { this.special.blink.timer -= deltaTime; if(this.special.blink.timer <= 0) this.special.blink.ready = true; } if(this.isDashing) return; this.updateStatusEffects(deltaTime); const baseSpeed = 5; this.vx = 0; if (input.keys.has('KeyA')) this.vx = -baseSpeed * this.speedModifier; if (input.keys.has('KeyD')) this.vx = baseSpeed * this.speedModifier; this.x += this.vx; this.vy += this.game.gravity; this.y += this.vy; let onPlatform = false; this.game.platforms.forEach(platform => { if (this.x < platform.x + platform.width && this.x + this.width > platform.x && this.y < platform.y + platform.height && this.y + this.height > platform.y && this.vy >= 0 && this.y + this.height - this.vy <= platform.y) { onPlatform = true; if (!this.onGround) this.land(); this.jumpsLeft = this.maxJumps; this.y = platform.y - this.height; this.vy = 0; } }); this.onGround = onPlatform; if (!this.onGround) this.fallTime += deltaTime; else this.fallTime = 0; if (this.x + this.width < 0) this.x = this.game.width - this.width; if (this.x > this.game.width) this.x = 0; if (this.isInvincible) { this.invincibilityTimer -= deltaTime; if (this.invincibilityTimer <= 0) this.isInvincible = false; } this.weaponAngle = Math.atan2(input.mouse.y - (this.y + this.height / 2 - 10) + this.game.cameraY, input.mouse.x - (this.x + this.width / 2) + this.game.cameraX); const canAttack = Date.now() - this.lastShotTime > this.shootCooldown / this.attackSpeedModifier; if (canAttack && (settings.get('autoAttack') || input.mouse.down)) { this.attack(); this.lastShotTime = Date.now(); } } land() { if (this.special.groundSlam && this.fallTime > 500) { this.game.audio.play('thunderStrike', 0.5); this.game.effects.push(new ShockwaveEffect(this.game, this.x + this.width/2, this.y + this.height, this.baseDamage * 2)); } } updateStatusEffects(deltaTime) { const burn = this.statusEffects.burn; if(burn.active) { burn.duration -= deltaTime; if(burn.duration <= 0) { burn.active = false; } else { this.hp -= burn.damagePerSecond * (deltaTime / 1000) * (1 - this.defense); if(this.hp <= 0) { this.hp = 0; this.game.gameOver(); } } } const silenced = this.statusEffects.silenced; if(silenced.active) { silenced.duration -= deltaTime; if(silenced.duration <= 0) silenced.active = false; } } applyBurn() { const burn = this.statusEffects.burn; if (burn.active) { burn.duration = 3000; } else { burn.active = true; burn.duration = 3000; burn.damagePerSecond = 5; } } jump() { if (this.jumpsLeft > 0) { this.game.audio.play('jump'); this.vy = -12 * this.jumpModifier; this.jumpsLeft--; this.onGround = false; } } attack() { if (this.statusEffects.silenced.active) return; if (this.characterType === 'wizard') { this.shoot(); } else if (this.characterType === 'gladiator') { this.meleeAttack(); } } shoot() { this.game.audio.play('bullet'); const isEmpowered = this.special.shotCounter === 4; const spread = Math.PI / 18; for (let i = 0; i < this.projectileCount; i++) { const angleOffset = (i - (this.projectileCount - 1) / 2) * spread; const angle = this.weaponAngle + angleOffset; const startX = this.x + this.width / 2 + Math.cos(angle) * this.weaponLength; const startY = this.y + this.height / 2 - 10 + Math.sin(angle) * this.weaponLength; this.game.projectiles.push(new Projectile(this.game, startX, startY, angle, this, 'normal', { empowered: isEmpowered })); } this.special.shotCounter = (this.special.shotCounter + 1) % 5; } meleeAttack() { this.game.audio.play('meleeSwing', 0.8); const startX = this.x + this.width / 2; const startY = this.y + this.height / 2 - 10; this.game.effects.push(new SlashEffect(this.game, startX, startY, this.weaponAngle, this, this.baseDamage * 1.5)); } dash() { this.isDashing = true; this.special.blink.ready = false; this.special.blink.timer = this.special.blink.cooldown; this.game.audio.play('dash'); const dashAngle = this.weaponAngle; const dashDistance = 200; for(let i=0; i< 20 * settings.get('particleDensity'); i++) this.game.particles.push(new Particle(this.game, this.x + this.width/2, this.y + this.height/2, 'cyan')); let newX = this.x + Math.cos(dashAngle) * dashDistance; let newY = this.y + Math.sin(dashAngle) * dashDistance; this.x = Math.max(0, Math.min(newX, this.game.width - this.width)); this.y = Math.max(0, Math.min(newY, this.game.height - this.height)); for(let i=0; i< 20 * settings.get('particleDensity'); i++) this.game.particles.push(new Particle(this.game, this.x + this.width/2, this.y + this.height/2, 'cyan')); setTimeout(() => this.isDashing = false, 150); } takeDamage(damage) { if (this.isInvincible || this.isDashing) return; if (this.special.barrier?.ready) { this.special.barrier.ready = false; this.isInvincible = true; this.invincibilityTimer = 300; this.game.audio.play('shieldBlock'); return; } this.game.audio.play('playerDamage'); const finalDamage = Math.max(1, (damage - this.flatDamageReduction) * (1 - this.defense)); this.hp -= finalDamage; this.isInvincible = true; this.invincibilityTimer = this.invincibilityDuration; this.game.triggerScreenShake(); if (this.hp <= 0) { this.hp = 0; this.game.gameOver(); } } gainExp(killCount = 1) { this.exp += killCount; if(this.characterType === 'gladiator') { const oldCounter = this.special.killCounter; this.special.killCounter += killCount; if(Math.floor(this.special.killCounter/20) > Math.floor(oldCounter/20)){ const hpGain = Math.floor(this.special.killCounter/20) - Math.floor(oldCounter/20); this.special.bonusHp += hpGain; this.maxHp += hpGain; this.hp += hpGain; } } if (this.exp >= this.expToNextLevel) { this.level++; this.exp -= this.expToNextLevel; this.expToNextLevel = Math.floor(10 * Math.pow(1.1, this.level)); this.game.levelUp(); } } applyUpgrade(upgradeId) { const upgrade = upgrades[upgradeId]; if(upgrade) { if(!this.upgrades[upgradeId]) this.upgrades[upgradeId] = 0; this.upgrades[upgradeId]++; upgrade.effect(this); } this.game.checkAchievements(); } }
            class Enemy { constructor(game, playerLevel, type = 'basic') { this.game = game; this.type = type; const waveFactor = 1 + (game.wave - 1) * 0.08; this.x = Math.random() * (game.width - 40); this.y = -50; this.state = 'descending'; this.targetY = game.enemyKeepAwayY + Math.random() * (game.height * 0.2); this.markedForDeletion = false; this.angle = 0; this.statusEffects = { frozen: { active: false, timer: 0 } }; switch(this.type) { case 'eye': this.image = this.game.assets.eye; this.width = 42; this.height = 37; this.speed = 0.9 + Math.random() * 0.4; this.maxHp = 15 * waveFactor; this.damage = 6 * waveFactor; this.shootCooldown = 2500 - game.wave * 30; this.expValue = 2; break; case 'demon': this.image = this.game.assets.demon; this.width = 36; this.height = 34; this.speed = 0.7 + Math.random() * 0.2; this.maxHp = 50 * waveFactor; this.damage = 10 * waveFactor; this.shootCooldown = 4000 - game.wave * 50; this.expValue = 5; break; default: this.image = this.game.assets.enemy; this.width = 32; this.height = 19; this.speed = 1.2 + Math.random() * 0.5; this.maxHp = 20 * waveFactor; this.damage = 8 * waveFactor; this.shootCooldown = 2200 - game.wave * 35; this.expValue = 1; break; } this.hp = this.maxHp; this.lastShotTime = Date.now() + Math.random() * 1000; } draw(ctx) { ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.angle); if(this.image?.complete) ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height); if(this.statusEffects.frozen.active) { ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height); } ctx.restore(); if(this.hp < this.maxHp) { ctx.fillStyle = 'rgba(255,0,0,0.7)'; ctx.fillRect(this.x, this.y - 8, this.width, 4); ctx.fillStyle = 'rgba(0,255,0,0.7)'; ctx.fillRect(this.x, this.y - 8, this.width * (this.hp/this.maxHp), 4); } } update(player, otherEnemies, deltaTime) { this.updateStatusEffects(deltaTime); if(this.statusEffects.frozen.active) return; let currentSpeed = this.speed; if (this.state === 'descending') { this.y += currentSpeed; if (this.y >= this.targetY) this.state = 'following'; } else if (this.state === 'following') { const dx = player.x - this.x; const dy = player.y - this.y; this.angle = Math.atan2(dy, dx) + Math.PI / 2; this.x += dx * 0.01 * currentSpeed; this.y += dy * 0.01 * currentSpeed; this.y = Math.max(this.y, this.game.enemyKeepAwayY); if (Date.now() - this.lastShotTime > this.shootCooldown) { this.shoot(player); this.lastShotTime = Date.now(); } } otherEnemies.forEach(other => { if(this === other) return; const dist = Math.hypot(this.x - other.x, this.y - other.y); if (dist < this.width) { const angle = Math.atan2(this.y - other.y, this.x - other.x); this.x += Math.cos(angle) * (this.width - dist) / 2; this.y += Math.sin(angle) * (this.width - dist) / 2; } }); } updateStatusEffects(deltaTime) { if (this.statusEffects.frozen.active) { this.statusEffects.frozen.timer -= deltaTime; if(this.statusEffects.frozen.timer <= 0) this.statusEffects.frozen.active = false; } } shoot(player) { this.game.audio.play('enemyShoot', 0.4); const angle = Math.atan2(player.y - this.y, player.x - this.x); let projectileType = 'normal'; if (this.type === 'demon') projectileType = 'fireball'; if (this.type === 'eye') projectileType = 'silencing_beam'; this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, angle, this, projectileType)); } takeDamage(amount, source) { if (this.markedForDeletion) return; this.hp -= amount; if (source instanceof Player && source.special.frostBolt) { this.statusEffects.frozen = { active: true, timer: 1000 }; } if (this.hp <= 0) { this.markedForDeletion = true; this.game.audio.play('enemyDeath'); this.game.createExplosion(this.x + this.width/2, this.y + this.height/2, this.width); if (source instanceof Player) { settings.set('totalKills', settings.get('totalKills') + 1); this.game.checkAchievements(); source.gainExp(this.expValue); if (source.special.fragmentation) { for (let i = 0; i < source.special.fragmentation; i++) this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, Math.random() * Math.PI * 2, source, 'fragment')); } if (source.special.healingOrbChance && Math.random() < source.special.healingOrbChance) { this.game.healingOrbs.push(new HealingOrb(this.game, this.x + this.width / 2, this.y + this.height / 2)); } } } } }
            class Projectile { constructor(game, x, y, angle, owner, type = 'normal', options = {}) { this.game = game; this.x = x; this.y = y; this.owner = owner; this.type = type; this.options = options; this.pierce = (owner instanceof Player) ? owner.pierceCount + (options.empowered ? 1 : 0) : 0; let speed = (owner instanceof Player) ? 10 : 5; this.radius = 5; this.isBeam = false; this.hitEnemies = new Set(); if (this.type === 'fragment') { this.damage = owner.baseDamage * 0.5; this.color = '#add8e6'; speed = 7; this.radius=3; } else if (this.type === 'silencing_beam') { this.color = '#dda0dd'; this.damage = 1; this.radius = 8; speed = 3; this.isBeam = true; } else if (owner instanceof Player) { this.damage = owner.baseDamage * (options.empowered ? 1.5 : 1); this.color = options.empowered ? '#FFD700' : '#00FFFF'; } else { this.damage = owner.damage; this.color = this.type === 'fireball' ? 'orange' : 'red'; } this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.markedForDeletion = false; this.trail = []; } draw(ctx) { ctx.save(); if (settings.get('bloom')) { ctx.shadowBlur = 10; ctx.shadowColor = this.color; } this.trail.forEach(t => { ctx.fillStyle = t.color; ctx.globalAlpha = t.alpha; ctx.beginPath(); ctx.arc(t.x, t.y, this.radius-2 > 0 ? this.radius-2 : 1, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0; if (this.isBeam) { ctx.translate(this.x, this.y); ctx.rotate(Math.atan2(this.vy, this.vx)); ctx.fillStyle = this.color; ctx.fillRect(-this.radius * 2, -this.radius / 2, this.radius * 4, this.radius); } else if (this.type === 'fireball') { ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } else { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); } update() { this.trail.push({x: this.x, y: this.y, alpha: 1.0, color: this.color}); this.trail.forEach(t => t.alpha -= 0.08 * (1/settings.get('particleDensity'))); this.trail = this.trail.filter(t => t.alpha > 0); this.x += this.vx; this.y += this.vy; if (this.x < -this.radius || this.x > this.game.width + this.radius || this.y < -this.radius || this.y > this.game.height + this.radius) this.markedForDeletion = true; } }
            class HealingOrb { constructor(game, x, y) { this.game = game; this.x = x; this.y = y; this.vy = 0; this.radius = 8; this.markedForDeletion = false; this.bobAngle = Math.random() * Math.PI * 2; this.onGround = false; } update() { this.bobAngle += 0.1; if (!this.onGround) { this.vy += this.game.gravity * 0.5; this.y += this.vy; this.game.platforms.forEach(platform => { if (this.x > platform.x && this.x < platform.x + platform.width && this.y + this.radius > platform.y && this.y < platform.y + platform.height) { this.y = platform.y - this.radius; this.vy *= -0.4; if (Math.abs(this.vy) < 1) { this.onGround = true; this.vy = 0; } } }); } } draw(ctx) { const bobY = this.onGround ? Math.sin(this.bobAngle) * 3 : 0; ctx.save(); if(settings.get('bloom')) { ctx.shadowBlur = 15; ctx.shadowColor = '#33ff33'; } ctx.globalAlpha = 0.8; ctx.fillStyle = '#33ff33'; ctx.beginPath(); ctx.arc(this.x, this.y + bobY, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#ffffff'; ctx.stroke(); ctx.restore(); } }
            class DamageNumber { constructor(game, x, y, amount, isCrit) { this.game = game; this.x = x; this.y = y; this.text = Math.floor(amount); this.life = 1000; this.vy = -1; this.isCrit = isCrit; } update(deltaTime) { this.y += this.vy * (deltaTime/16); this.life -= deltaTime; if (this.life <= 0) this.markedForDeletion = true; } draw(ctx) { if (!settings.get('showDamageNumbers')) return; ctx.save(); ctx.globalAlpha = this.life / 1000; ctx.font = this.isCrit ? "24px VT323" : "18px VT323"; ctx.fillStyle = this.isCrit ? "yellow" : "white"; if(settings.get('bloom')) { ctx.shadowBlur = this.isCrit ? 10 : 5; ctx.shadowColor = this.isCrit ? "yellow" : "white"; } else { ctx.shadowColor = 'black'; ctx.shadowBlur = 4; } ctx.fillText(this.text, this.x, this.y); ctx.restore(); } }
            class Platform { constructor(x, y, width, height) { this.x = x; this.y = y; this.width = width; this.height = height; } draw(ctx) { const isAero = settings.get('frutigerAero'); ctx.fillStyle = isAero ? 'rgba(150, 200, 255, 0.2)' : 'transparent'; ctx.strokeStyle = isAero ? 'rgba(230, 245, 255, 0.7)' : '#fff'; ctx.lineWidth = isAero ? 3 : 2; if (isAero) ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); } }
            class Star { constructor(game) { this.game = game; this.parallax = Math.random() * 0.4 + 0.1; this.reset(); } reset() { this.x = Math.random() * this.game.width; this.y = Math.random() * this.game.height; this.size = Math.random() * 1.5 + 0.5; this.brightness = Math.random() * 0.5 + 0.5; } update() { this.y += 0.1; if (this.y > this.game.height) { this.y = 0; this.x = Math.random() * this.game.width; } } draw(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`; ctx.fillRect(this.x, this.y, this.size, this.size); } }
            class Particle { constructor(game, x, y, color, sizeMultiplier=1) { this.game = game; this.x = x; this.y = y; this.color = color; this.size = (Math.random() * 3 + 1) * sizeMultiplier; this.life = Math.random() * 500 + 200; this.vx = Math.random() * 4 - 2; this.vy = Math.random() * 4 - 2; this.markedForDeletion = false; } draw(ctx) { ctx.save(); if(settings.get('bloom')) { ctx.shadowBlur = 10; ctx.shadowColor = this.color; } ctx.globalAlpha = this.life / 500; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.restore(); } update(deltaTime) { this.x += this.vx; this.y += this.vy; this.life -= deltaTime; if(this.life <= 0) this.markedForDeletion = true; } }
            class Notifier { constructor(game, text, title, icon, color) { this.game = game; this.text = text; this.title = title; this.icon = icon; this.color = color; this.width = 400; this.height = 50; this.x = game.width / 2 - this.width / 2; this.y = -this.height; this.targetY = 10; this.life = 4000; this.state = 'sliding_in'; } update(deltaTime) { this.life -= deltaTime; if(this.state === 'sliding_in') { this.y += (this.targetY - this.y) * 0.1; if(Math.abs(this.y - this.targetY) < 1) { this.y = this.targetY; this.state = 'waiting'; } } if(this.life <= 1000) { this.state = 'fading_out'; } if(this.life <= 0) this.markedForDeletion = true; } draw(ctx) { ctx.save(); if(this.state === 'fading_out') ctx.globalAlpha = this.life / 1000; ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.strokeStyle = this.color; ctx.lineWidth = 3; if (ctx.roundRect) { ctx.roundRect(this.x, this.y, this.width, this.height, [10]); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); } ctx.fillStyle = this.color; ctx.font = "20px Cinzel"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(`${this.icon} ${this.title}`, this.x + this.width / 2, this.y + this.height * 0.35); ctx.fillStyle = 'white'; ctx.font = "16px VT323"; ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height * 0.7); ctx.restore(); } }
            class SlashEffect { constructor(game, x, y, angle, owner, damage) { this.game = game; this.x = x; this.y = y; this.startAngle = angle - Math.PI / 4; this.endAngle = angle + Math.PI / 4; this.radius = 70; this.life = 150; this.owner = owner; this.damage = damage; this.hitEnemies = new Set(); this.markedForDeletion = false; } update(deltaTime) { this.life -= deltaTime; if (this.life <= 0) this.markedForDeletion = true; } draw(ctx) { ctx.save(); ctx.globalAlpha = (this.life / 150) * 0.8; ctx.fillStyle = 'white'; if(settings.get('bloom')) { ctx.shadowBlur = 15; ctx.shadowColor = '#fff'; } ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle); ctx.closePath(); ctx.fill(); ctx.restore(); } }
            class ShockwaveEffect { constructor(game, x, y, damage) { this.game = game; this.x = x; this.y = y; this.radius = 0; this.maxRadius = 150; this.life = 300; this.damage = damage; this.hitEnemies = new Set(); this.markedForDeletion = false; } update(deltaTime) { this.life -= deltaTime; this.radius += (this.maxRadius - this.radius) * 0.2; if (this.life <= 0) this.markedForDeletion = true; } draw(ctx) { ctx.save(); ctx.globalAlpha = (this.life / 300) * 0.7; ctx.strokeStyle = '#FFF'; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.stroke(); ctx.restore(); } }
            
            class CursedGroundEffect { constructor(game, x, y) { this.game = game; this.x = x; this.y = y; this.radius = 80; this.life = 8000; this.markedForDeletion = false; this.alpha = 0; } update(deltaTime) { this.life -= deltaTime; if(this.life > 7000) this.alpha = (8000 - this.life) / 1000; else if (this.life < 1000) this.alpha = this.life / 1000; else this.alpha = 1; if(this.life <= 0) this.markedForDeletion = true; } draw(ctx) { ctx.save(); ctx.globalAlpha = this.alpha * 0.7; ctx.fillStyle = '#d44'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); for(let i=0; i < 3 * settings.get('particleDensity'); i++) { ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${this.alpha * 0.5})`; ctx.beginPath(); ctx.arc(this.x + (Math.random() - 0.5) * this.radius, this.y + (Math.random() - 0.5) * (this.radius/4), Math.random() * 10, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); } }
            class ScytheBeamEffect { constructor(game, startX, startY, angle) { this.game = game; this.x = startX; this.y = startY; this.angle = angle; this.state = 'telegraphing'; this.timer = 1000; this.markedForDeletion = false; this.damage = 40; } update(deltaTime) { this.timer -= deltaTime; if (this.timer <= 0) { if (this.state === 'telegraphing') { this.state = 'firing'; this.timer = 500; this.game.triggerScreenShake(); this.game.audio.play('thunderStrike', 1.2); } else { this.markedForDeletion = true; } } } draw(ctx) { ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); if(this.state === 'telegraphing') { ctx.globalAlpha = 0.8; ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; ctx.fillRect(0, -2, this.game.width * 1.5, 4); } else if (this.state === 'firing') { ctx.globalAlpha = 1.0; ctx.fillStyle = '#ff4757'; if(settings.get('bloom')) { ctx.shadowBlur = 25; ctx.shadowColor = '#d44'; } ctx.fillRect(0, -20, this.game.width * 1.5, 40); } ctx.restore(); } }

            class Boss extends Enemy { 
                constructor(game, level) { 
                    super(game, level, 'boss'); 
                    this.level = level; 
                    this.phase = 1; 
                    this.state = 'intro'; 
                    this.targetY = game.height * 0.15; 

                    if (level === 5) { // First Boss (Easier)
                        this.image = this.game.assets.boss1; 
                        this.width = 62 * 2; this.height = 67 * 2; 
                        this.maxHp = 1100 * (1 + (game.wave-1)*0.1); 
                        this.phase1AttackPattern = [ 
                            { type: 'multi-shot', duration: 6000, timer: 6000 }, 
                            { type: 'spawn-minions', duration: 12000, timer: 12000 }, 
                            { type: 'cursed-ground', duration: 9000, timer: 9000 } 
                        ];
                        this.phase2AttackPattern = [ 
                            { type: 'multi-shot', duration: 4000, timer: 4000 }, 
                            { type: 'spawn-minions', duration: 10000, timer: 10000 }, 
                            { type: 'scythe-sweep', duration: 8500, timer: 8500 } 
                        ];
                    } else { // Second Boss (Harder)
                        this.image = this.game.assets.boss2; 
                        this.width = 63 * 2; this.height = 61 * 2; 
                        this.maxHp = 3000 * (1 + (game.wave-1)*0.1);
                        this.phase1AttackPattern = [ 
                            { type: 'multi-shot', duration: 5000, timer: 5000 }, 
                            { type: 'spawn-minions', duration: 10000, timer: 10000 }, 
                            { type: 'cursed-ground', duration: 8000, timer: 8000 } 
                        ];
                        this.phase2AttackPattern = [ 
                            { type: 'multi-shot', duration: 3500, timer: 3500 }, 
                            { type: 'spawn-minions', duration: 8000, timer: 8000 }, 
                            { type: 'scythe-sweep', duration: 7000, timer: 7000 } 
                        ];
                    }

                    this.currentAttackPattern = this.phase1AttackPattern; 
                    this.hp = this.maxHp; 
                    this.introMoveDir = 1; 
                    this.introSpeed = 1; 
                } 
                update(player, otherEnemies, deltaTime) { if (this.state === 'intro' || this.state === 'transitioning') { if (this.state === 'intro') { this.y += (this.targetY - this.y) * 0.02; this.x += this.introMoveDir * this.introSpeed; if (this.x > this.game.width * 0.7 || this.x < this.game.width * 0.3) this.introMoveDir *= -1; } return; } if (this.state === 'active') { this.currentAttackPattern.forEach(pattern => { pattern.timer -= deltaTime; if (pattern.timer <= 0) { pattern.timer = pattern.duration; if(pattern.type === 'multi-shot') this.multiShot(player); if(pattern.type === 'spawn-minions') this.spawnMinions(); if(pattern.type === 'cursed-ground') this.createCursedGround(); if(pattern.type === 'scythe-sweep') this.scytheSweep(player); } }); } } 
                takeDamage(amount, source) { if(this.state !== 'active') return; super.takeDamage(amount, source); if (this.phase === 1 && this.hp / this.maxHp <= 0.5) { this.transitionToPhase2(); } } 
                transitionToPhase2() { this.phase = 2; this.state = 'transitioning'; this.game.triggerScreenShake(); this.game.audio.play('playerDeath', 0.8); for(let i=0; i < 100 * settings.get('particleDensity'); i++) this.game.particles.push(new Particle(this.game, this.x + this.width/2, this.y + this.height/2, '#d44', 2)); setTimeout(() => { this.state = 'active'; this.currentAttackPattern = this.phase2AttackPattern; }, 2000); } 
                multiShot(player) { const numShots = this.phase === 1 ? 5 : 7; const spread = Math.PI / 8; for (let i = 0; i < numShots; i++) { const angle = Math.atan2(player.y - this.y, player.x - this.x) + (i - (numShots - 1) / 2) * spread; this.game.projectiles.push(new Projectile(this.game, this.x + this.width / 2, this.y + this.height / 2, angle, this)); } } 
                spawnMinions() { 
                    let count = 0;
                    let minionType = 'basic';
                    if (this.level === 5) { // First boss logic
                        count = this.phase === 1 ? 3 : 1;
                        minionType = this.phase === 1 ? 'basic' : 'eye';
                    } else { // Second boss logic
                        count = this.phase === 1 ? 3 : 2;
                        minionType = 'eye';
                    }
                    for(let i=0; i<count; i++) { const minion = new Enemy(this.game, this.game.player.level, minionType); minion.x = this.x + (Math.random() - 0.5) * this.width; minion.y = this.y + this.height; this.game.enemies.push(minion); } 
                } 
                createCursedGround() { this.game.effects.push(new CursedGroundEffect(this.game, this.game.width * 0.25, this.game.height - 40)); this.game.effects.push(new CursedGroundEffect(this.game, this.game.width * 0.75, this.game.height - 40)); } 
                scytheSweep(player) { const angle = Math.atan2(player.y - this.y, player.x - this.x); this.game.effects.push(new ScytheBeamEffect(this.game, this.x + this.width/2, this.y + this.height/2, angle)); } 
                draw(ctx) { super.draw(ctx); const barWidth = this.game.width * 0.6; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(this.game.width * 0.2 - 2, 18, barWidth + 4, 24); ctx.fillStyle = '#550000'; ctx.fillRect(this.game.width * 0.2, 20, barWidth, 20); ctx.fillStyle = this.phase === 1 ? '#c0392b' : '#ff4757'; ctx.fillRect(this.game.width * 0.2, 20, barWidth * (this.hp / this.maxHp), 20); } 
            }
            class DialogueBox { constructor(game, text) { this.game = game; this.fullText = text; this.displayedText = ''; this.charIndex = 0; this.typingSpeed = 50; this.timer = 0; this.isFinished = false; this.x = this.game.width * 0.1; this.y = this.game.height * 0.75; this.width = this.game.width * 0.8; this.height = this.game.height * 0.2; } update(deltaTime) { if (this.isFinished) return; this.timer += deltaTime; if (this.timer >= this.typingSpeed) { this.timer = 0; if (this.charIndex < this.fullText.length) { this.displayedText += this.fullText[this.charIndex]; this.charIndex++; this.game.audio.play('key', 0.4); } else { setTimeout(() => this.isFinished = true, 1000); } } } draw(ctx) { ctx.save(); ctx.globalAlpha = 0.8; ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.strokeStyle = 'white'; ctx.lineWidth = 3; ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); ctx.fillStyle = 'white'; ctx.font = '24px VT323'; ctx.textAlign = 'left'; ctx.textBaseline = 'top'; const lines = this.displayedText.split('\n'); lines.forEach((line, i) => { ctx.fillText(line, this.x + 20, this.y + 20 + (i * 28)); }); ctx.restore(); } }
            class CutsceneManager { constructor(game, level) { this.game = game; this.level = level; this.state = 'dialogue_start'; this.dialogueBox = null; this.boss = null; } update(deltaTime) { switch (this.state) { case 'dialogue_start': const text = this.level === 5 ? "You've survived... for now.\nLet's see how you handle a real threat." : "Impressive. But your stand ends here.\nFace oblivion!"; this.dialogueBox = new DialogueBox(this.game, text); this.state = 'dialogue_typing'; break; case 'dialogue_typing': this.dialogueBox.update(deltaTime); if (this.dialogueBox.isFinished) { this.state = 'boss_reveal'; } break; case 'boss_reveal': this.dialogueBox = null; this.boss = new Boss(this.game, this.level); this.game.enemies.push(this.boss); this.game.cameraZoomTarget = 0.8; this.game.audio.startMusic(`boss${this.level === 5 ? 1 : 2}`); this.state = 'camera_pan'; break; case 'camera_pan': if (Math.abs(this.game.cameraZoom - this.game.cameraZoomTarget) < 0.01) { this.state = 'finished'; } break; case 'finished': this.boss.state = 'active'; this.game.endCutscene(); break; } } draw(ctx) { if (this.dialogueBox) { this.dialogueBox.draw(ctx); } } }

            class Game {
                constructor(width, height, images, audioManager, characterType) { this.width = width; this.height = height; this.assets = images; this.audio = audioManager; this.player = new Player(this, characterType); this.platforms = this.createPlatforms(); this.enemies = []; this.projectiles = []; this.particles = []; this.healingOrbs = []; this.effects = []; this.damageNumbers = []; this.notifiers = []; this.stars = []; this.createStars(); this.gravity = 0.5; this.gameState = 'playing'; this.wave = 1; this.score = 0; this.lastTime = 0; this.enemyKeepAwayY = this.height * 0.1; this.cameraX = 0; this.cameraY = 0; this.cameraSmoothing = 0.05; this.cameraZoom = 1.0; this.cameraZoomTarget = 1.0; this.rerollsUsedThisLevel = false; this.bossActive = false; this.bossDefeatedLevels = []; this.cutsceneManager = null; this.setupInput(); this.audio.startMusic('soundtrack');}
                createPlatforms() { return [ new Platform(0, this.height - 40, this.width, 40), new Platform(100, this.height - 120, 150, 20), new Platform(this.width - 250, this.height - 120, 150, 20), new Platform(this.width/2 - 100, this.height - 200, 200, 20), new Platform(this.width/2 - 350, this.height - 300, 150, 20), new Platform(this.width/2 + 200, this.height - 300, 150, 20)]; }
                createStars() { this.stars = []; for(let i=0; i < 200 * settings.get('particleDensity'); i++) this.stars.push(new Star(this)); }
                setupInput() { window.addEventListener('keydown', e => { if(e.code === 'Space' && (this.gameState === 'playing' || this.gameState === 'bossWave')) this.player.jump(); }); }
                update(timestamp) { const deltaTime = (timestamp - (this.lastTime || timestamp)) || 16.67; this.lastTime = timestamp; this.updateCamera(); this.stars.forEach(s => s.update()); if (this.gameState === 'cutscene') { this.cutsceneManager.update(deltaTime); this.enemies.forEach(e => e.update(this.player, this.enemies, deltaTime)); this.player.update(inputHandler, deltaTime); return; } this.score += deltaTime/10; this.wave = 1 + Math.floor(this.player.level / 3); if(this.player.y > this.height + 200) this.handleOutOfBounds(); this.player.update(inputHandler, deltaTime); const bossLevel = [5, 10].find(lvl => this.player.level >= lvl && !this.bossDefeatedLevels.includes(lvl) && !this.bossActive); if(bossLevel) { this.startBossCutscene(bossLevel); } if (this.gameState === 'playing') { const maxEnemies = 5 + Math.floor(this.player.level * 1.5); if (this.enemies.length < maxEnemies) { let spawnPool = ['basic', 'basic', 'basic']; if (this.player.level >= 4) spawnPool.push('eye', 'eye'); if (this.player.level >= 8) spawnPool.push('demon'); const enemyType = spawnPool[Math.floor(Math.random() * spawnPool.length)]; this.enemies.push(new Enemy(this, this.player.level, enemyType)); } } this.enemies.forEach(e => e.update(this.player, this.enemies, deltaTime)); this.projectiles.forEach(p => p.update()); this.particles.forEach(p => p.update(deltaTime)); this.healingOrbs.forEach(o => o.update()); this.damageNumbers.forEach(dn => dn.update(deltaTime)); this.notifiers.forEach(an => an.update(deltaTime)); this.updateUpgrades(deltaTime); this.updateEffects(deltaTime); this.checkCollisions(); const boss = this.enemies.find(e => e instanceof Boss); if (this.bossActive && boss && boss.markedForDeletion) { this.endBossWave(boss.level); } this.enemies = this.enemies.filter(e => !e.markedForDeletion); this.projectiles = this.projectiles.filter(p => !p.markedForDeletion); this.particles = this.particles.filter(p => !p.markedForDeletion); this.healingOrbs = this.healingOrbs.filter(o => !o.markedForDeletion); this.effects = this.effects.filter(e => !e.markedForDeletion); this.damageNumbers = this.damageNumbers.filter(dn => !dn.markedForDeletion); this.notifiers = this.notifiers.filter(an => !an.markedForDeletion); this.updateHUD(); }
                updateHUD() { elements.hpText.textContent = `HP: ${Math.ceil(this.player.hp)}/${this.player.maxHp}`; elements.expText.textContent = `LVL: ${this.player.level}`; elements.hpBar.style.width = `${(this.player.hp / this.player.maxHp) * 100}%`; elements.expBar.style.width = `${(this.player.exp / this.player.expToNextLevel) * 100}%`; }
                handleOutOfBounds() { this.player.takeDamage(10); this.notifiers.push(new Notifier(this, "We're working on that bug!", "You fell into the void...", 'üêõ', '#ff4757')); this.player.x = this.width / 2; this.player.y = this.height / 2; this.player.vy = 0; }
                startBossCutscene(level) { this.gameState = 'cutscene'; this.bossActive = true; this.enemies = []; this.audio.stopAllMusic(); this.cutsceneManager = new CutsceneManager(this, level); }
                endCutscene() { this.cutsceneManager = null; this.gameState = 'bossWave'; }
                endBossWave(level) { this.gameState = 'playing'; this.bossActive = false; this.bossDefeatedLevels.push(level); this.player.gainExp(50); this.audio.startMusic('soundtrack'); this.cameraZoomTarget = 1.0; }
                updateCamera() { let targetX, targetY; if (settings.get('cameraMode') === 'static' && !this.bossActive) { this.cameraZoomTarget = 0.65; targetX = 0; targetY = -this.height * 0.15; } else { this.cameraZoomTarget = this.bossActive ? 0.8 : 1.0; targetX = this.player.x + this.player.width / 2 - this.width / 2; targetY = this.player.y + this.player.height / 2 - this.height / 2; if (this.bossActive) { const boss = this.enemies.find(e => e instanceof Boss); if (boss) { targetY = (this.player.y + boss.y) / 2 - this.height / 2; } } } this.cameraZoom += (this.cameraZoomTarget - this.cameraZoom) * 0.02; this.cameraX += (targetX - this.cameraX) * this.cameraSmoothing; this.cameraY += (targetY - this.cameraY) * this.cameraSmoothing; }
                draw(ctx) { ctx.save(); ctx.translate(this.width/2, this.height/2); ctx.scale(this.cameraZoom, this.cameraZoom); ctx.translate(-this.width/2, -this.height/2); ctx.save(); ctx.translate(-this.cameraX * 0.2, -this.cameraY * 0.2); this.stars.forEach(s => { if(s.parallax > 0.3) s.draw(ctx) }); ctx.restore(); ctx.save(); ctx.translate(-this.cameraX * 0.4, -this.cameraY * 0.4); this.stars.forEach(s => { if(s.parallax <= 0.3) s.draw(ctx) }); ctx.restore(); ctx.translate(-this.cameraX, -this.cameraY); this.platforms.forEach(p => p.draw(ctx)); this.effects.forEach(e => e.draw(ctx)); this.healingOrbs.forEach(o => o.draw(ctx)); this.player.draw(ctx); this.enemies.forEach(e => e.draw(ctx)); this.projectiles.forEach(p => p.draw(ctx)); this.particles.forEach(p => p.draw(ctx)); this.damageNumbers.forEach(dn => dn.draw(ctx)); ctx.restore(); this.notifiers.forEach(an => an.draw(ctx)); if (this.cutsceneManager) { this.cutsceneManager.draw(ctx); } }
                updateUpgrades(deltaTime) { if (this.player.special.thunderbolt) { const tb = this.player.special.thunderbolt; tb.timer -= deltaTime; if (tb.timer <= 0) { tb.timer = tb.interval; this.createThunderboltOnEnemy(); } } if (this.player.special.barrier) { const ba = this.player.special.barrier; if(!ba.ready) { ba.timer -= deltaTime; if(ba.timer <= 0) { ba.ready = true; ba.timer = ba.cooldown; } } } }
                updateEffects(deltaTime) { this.effects.forEach(effect => effect.update(deltaTime)); }
                checkAchievements() { const unlocked = settings.get('unlockedAchievements'); for(const id in achievements) { if(!unlocked.includes(id) && achievements[id].check(this)) { unlocked.push(id); settings.set('unlockedAchievements', unlocked); this.audio.play('achievement'); this.notifiers.push(new Notifier(this, achievements[id].name, 'Achievement Unlocked!', 'üèÜ', 'gold')); } } }
                createThunderboltOnEnemy() { if(this.enemies.length === 0) return; const targetableEnemies = this.enemies.filter(e => !(e instanceof Boss)); if(targetableEnemies.length === 0) return; const target = targetableEnemies[Math.floor(Math.random() * targetableEnemies.length)]; this.createThunderboltEffect(target.x + target.width/2); }
                createThunderboltEffect(strikeX) { const damage = 50; const radius = 60; const warningTime = 1000; const strikeTime = 200; const effect = { x: strikeX, timer: warningTime, state: 'warning', markedForDeletion: false, update: (delta) => { effect.timer -= delta; if (effect.timer <= 0) { if (effect.state === 'warning') { effect.state = 'strike'; effect.timer = strikeTime; this.triggerScreenShake(); this.audio.play('thunderStrike'); this.enemies.forEach(enemy => { if(this.rectCircleColliding({x: enemy.x, y: enemy.y, width: enemy.width, height: enemy.height}, {x: strikeX, y: enemy.y + enemy.height/2, r: radius})) { enemy.takeDamage(damage, this.player); this.damageNumbers.push(new DamageNumber(this, enemy.x + enemy.width / 2, enemy.y, damage, false)); } }); for(let i=0; i < 50 * settings.get('particleDensity'); i++) this.particles.push(new Particle(this, strikeX + (Math.random() - 0.5) * radius * 2, 'yellow', 1.5)); } else { effect.markedForDeletion = true; } } }, draw: (ctx) => { if (effect.state === 'warning') { const alpha = 1 - (effect.timer / warningTime); ctx.fillStyle = 'rgba(255, 255, 100, 0.3)'; ctx.beginPath(); ctx.ellipse(strikeX, this.height - 20, radius, radius/4, 0, 0, Math.PI * 2); ctx.fill(); } else if (effect.state === 'strike') { ctx.save(); ctx.strokeStyle = 'yellow'; ctx.lineWidth = 5; if(settings.get('bloom')) { ctx.shadowColor = 'yellow'; ctx.shadowBlur = 20; } ctx.beginPath(); ctx.moveTo(strikeX, 0); let currentX = strikeX; for (let y = 0; y < this.height; y += 20) { currentX += (Math.random() - 0.5) * 30; ctx.lineTo(currentX, y); } ctx.lineTo(currentX, this.height); ctx.stroke(); ctx.restore(); } } }; this.effects.push(effect); }
                checkCollisions() { this.projectiles.forEach(p => { if (p.owner instanceof Player) { this.enemies.forEach(e => { if(!e.markedForDeletion && !p.hitEnemies.has(e) && this.rectCircleColliding({ x: e.x, y: e.y, width: e.width, height: e.height }, { x: p.x, y: p.y, r: p.radius })) { const isCrit = Math.random() < this.player.critChance; const damage = isCrit ? p.damage * this.player.critDamageModifier : p.damage; e.takeDamage(damage, p.owner); p.hitEnemies.add(e); this.damageNumbers.push(new DamageNumber(this, e.x + e.width / 2, e.y, damage, isCrit)); if(this.player.lifesteal > 0) this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.lifesteal * damage); if(this.player.special.chainLightning && Math.random() < this.player.special.chainLightning){ const availableTargets = this.enemies.filter(en => en !== e && !p.hitEnemies.has(en) && Math.hypot(e.x-en.x, e.y-en.y) < 200); if(availableTargets.length > 0) { const target = availableTargets[0]; const newProj = new Projectile(this, e.x, e.y, Math.atan2(target.y-e.y, target.x-e.x), p.owner, 'normal', {empowered: false}); newProj.pierce = 0; this.projectiles.push(newProj); } } if(p.pierce <= 0) p.markedForDeletion = true; else p.pierce--; }}); } else { if(this.rectCircleColliding({x: this.player.x, y: this.player.y, width: this.player.width, height: this.player.height}, {x: p.x, y: p.y, r: p.radius})) { if (p.type === 'silencing_beam') { this.player.takeDamage(p.damage); this.player.statusEffects.silenced = { active: true, duration: 2000 }; } else { this.player.takeDamage(p.damage); if (p.type === 'fireball') this.player.applyBurn(); } p.markedForDeletion = true; } } }); this.effects.forEach(effect => { if(effect instanceof SlashEffect || effect instanceof ShockwaveEffect) { this.enemies.forEach(enemy => { if (!effect.hitEnemies.has(enemy)) { const dist = Math.hypot(enemy.x + enemy.width / 2 - effect.x, enemy.y + enemy.height / 2 - effect.y); if (dist < effect.radius) { enemy.takeDamage(effect.damage, this.player); this.damageNumbers.push(new DamageNumber(this, enemy.x + enemy.width / 2, enemy.y, effect.damage, true)); const knockbackAngle = Math.atan2(enemy.y - effect.y, enemy.x - effect.x); enemy.x += Math.cos(knockbackAngle) * 15; enemy.y += Math.sin(knockbackAngle) * 15; effect.hitEnemies.add(enemy); } } }); } else if (effect instanceof CursedGroundEffect) { if(this.rectCircleColliding({x: this.player.x, y: this.player.y, width: this.player.width, height: this.player.height}, {x: effect.x, y: effect.y, r: effect.radius})) { this.player.applyBurn(); } } else if (effect instanceof ScytheBeamEffect && effect.state === 'firing') { const playerRect = {x: this.player.x, y: this.player.y, width: this.player.width, height: this.player.height}; if (this.lineRectColliding(effect, playerRect)) { this.player.takeDamage(effect.damage); } } }); this.healingOrbs.forEach(orb => { if (Math.hypot(orb.x - (this.player.x + this.player.width/2), orb.y - (this.player.y + this.player.height/2)) < 80) { orb.x += ((this.player.x + this.player.width/2) - orb.x) * 0.1; orb.y += ((this.player.y + this.player.height/2) - orb.y) * 0.1; } if (this.rectCircleColliding({ x: this.player.x, y: this.player.y, width: this.player.width, height: this.player.height }, { x: orb.x, y: orb.y, r: orb.radius * 2 })) { this.player.hp = Math.min(this.player.maxHp, this.player.hp + 10); this.audio.play('cardPickup', 0.6); orb.markedForDeletion = true; } }); }
                rectCircleColliding(rect, circle) { let testX = circle.x, testY = circle.y; if (circle.x < rect.x) testX = rect.x; else if (circle.x > rect.x + rect.width) testX = rect.x + rect.width; if (circle.y < rect.y) testY = rect.y; else if (circle.y > rect.y + rect.height) testY = rect.y + rect.height; return Math.hypot(circle.x - testX, circle.y - testY) <= circle.r; }
                lineRectColliding(line, rect) { const x1 = line.x, y1 = line.y; const x2 = line.x + Math.cos(line.angle) * this.width * 1.5; const y2 = line.y + Math.sin(line.angle) * this.width * 1.5; const left = this.lineLine(x1, y1, x2, y2, rect.x, rect.y, rect.x, rect.y + rect.height); const right = this.lineLine(x1, y1, x2, y2, rect.x + rect.width, rect.y, rect.x + rect.width, rect.y + rect.height); const top = this.lineLine(x1, y1, x2, y2, rect.x, rect.y, rect.x + rect.width, rect.y); const bottom = this.lineLine(x1, y1, x2, y2, rect.x, rect.y + rect.height, rect.x + rect.width, rect.y + rect.height); return left || right || top || bottom; }
                lineLine(x1, y1, x2, y2, x3, y3, x4, y4) { const uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)); const uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1)); return (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1); }
                triggerScreenShake() { if (settings.get('screenShake')) { elements.gameContainer.classList.add('shake'); setTimeout(() => elements.gameContainer.classList.remove('shake'), 100); } }
                togglePause() { if (this.gameState === 'cutscene') return; if(elements.settingsScreen.classList.contains('hidden') && elements.achievementsScreen.classList.contains('hidden')) { this.gameState = this.gameState === 'playing' || this.gameState === 'bossWave' ? 'paused' : (this.bossActive ? 'bossWave' : 'playing'); if (this.gameState === 'paused') { this.updatePauseScreenInfo(); this.audio.stopAllMusic(); } else { if (this.bossActive) this.audio.startMusic(`boss${this.bossDefeatedLevels.length === 0 ? 1: 2}`); else this.audio.startMusic('soundtrack'); } elements.pauseScreen.classList.toggle('hidden'); this.audio.play('click'); } }
                updatePauseScreenInfo() { const statsContainer = document.getElementById('pauseStats'); const upgradesContainer = document.getElementById('pauseUpgrades'); statsContainer.innerHTML = '<h3>Player Stats</h3>'; upgradesContainer.innerHTML = '<h3>Current Upgrades</h3>'; const p = this.player; statsContainer.innerHTML += `<p>HP: ${Math.ceil(p.hp)} / ${p.maxHp}</p><p>Dano Base: ${p.baseDamage.toFixed(1)}</p><p>Defesa: ${(p.defense * 100).toFixed(0)}%</p><p>Velocidade Mov.: ${(p.speedModifier * 100).toFixed(0)}%</p><p>Velocidade Ataque: ${(p.attackSpeedModifier * 100).toFixed(0)}%</p><p>Chance Cr√≠tica: ${(p.critChance * 100).toFixed(0)}%</p><p>Dano Cr√≠tico: ${(p.critDamageModifier * 100).toFixed(0)}%</p><p>Roubo de Vida: ${(p.lifesteal * 100).toFixed(1)}%</p>`; if (Object.keys(p.upgrades).length === 0) { upgradesContainer.innerHTML += '<p>No upgrades collected yet.</p>'; } else { for(const id in p.upgrades) { const upgradeInfo = upgrades[id]; if (upgradeInfo) { const upgradeEl = document.createElement('div'); upgradeEl.className = `upgrade-item ${upgradeInfo.rarity}`; upgradeEl.textContent = `${upgradeInfo.name} ${upgradeInfo.maxLevel > 1 ? `Nv. ${p.upgrades[id]}`:''}`; upgradesContainer.appendChild(upgradeEl); } } } }
                gameOver() { this.gameState = 'gameOver'; settings.set('totalDeaths', settings.get('totalDeaths') + 1); this.checkAchievements(); this.audio.stopAllMusic(); this.audio.play('playerDeath'); elements.scoreText.textContent = `Score: ${Math.floor(this.score)}`; if(Math.floor(this.score) > settings.get('highScore')) { settings.set('highScore', Math.floor(this.score)); elements.highScoreText.textContent = `NEW HIGH SCORE: ${Math.floor(this.score)}`; } else { elements.highScoreText.textContent = `High Score: ${settings.get('highScore')}`; } elements.gameOverScreen.classList.remove('hidden'); }
                levelUp() { this.gameState = 'levelUp'; this.rerollsUsedThisLevel = false; this.audio.play('levelUp'); this.showUpgradeCards(); }
                createExplosion(x, y, size) { for(let i=0; i < (size/2) * settings.get('particleDensity'); i++) { this.particles.push(new Particle(this, x, y, `hsl(${Math.random() * 60}, 100%, 50%)`)); }}
                showUpgradeCards() { const cardContainer = elements.levelUpScreen.querySelector('.card-container'); cardContainer.innerHTML = ''; elements.rerollButton.disabled = this.rerollsUsedThisLevel; elements.rerollButton.textContent = this.rerollsUsedThisLevel ? 'Reroll Used' : 'Reroll'; let availableUpgrades = Object.keys(upgrades).filter(id => { const upg = upgrades[id]; const currentLevel = this.player.upgrades[id] || 0; return currentLevel < upg.maxLevel; }); let choices = []; for(let i=0; i < this.player.upgradeChoices; i++) { if(availableUpgrades.length === 0) break; let choiceIndex = Math.floor(Math.random() * availableUpgrades.length); let choiceId = availableUpgrades.splice(choiceIndex, 1)[0]; choices.push(choiceId); } choices.forEach(upgradeId => { const upgrade = upgrades[upgradeId]; const cardEl = document.createElement('div'); const currentLevel = this.player.upgrades[upgradeId] || 0; const nextLevel = currentLevel + 1; cardEl.className = `card ${upgrade.rarity}`; cardEl.dataset.upgradeId = upgradeId; let title = `${upgrade.name} ${upgrade.maxLevel > 1 ? `Nv. ${nextLevel}` : ''}`; cardEl.innerHTML = `<h3 class="card-title">${title}</h3><div class="card-icon">${upgrade.name.charAt(0)}</div><p class="card-description">${upgrade.getDescription(nextLevel)}</p>`; cardContainer.appendChild(cardEl); }); elements.levelUpScreen.classList.remove('hidden'); this.attachCardEvents(); }
                attachCardEvents() { const cards = elements.levelUpScreen.querySelectorAll('.card'); let isAnimating = false; const rerollHandler = () => { if(this.rerollsUsedThisLevel) return; this.rerollsUsedThisLevel = true; this.audio.play('reroll'); this.showUpgradeCards(); elements.rerollButton.removeEventListener('click', rerollHandler); }; elements.rerollButton.addEventListener('click', rerollHandler); cards.forEach((hoveredCard, hoveredIndex) => { hoveredCard.addEventListener('mouseenter', () => { if (isAnimating) return; cards.forEach((otherCard, otherIndex) => { if (hoveredIndex === otherIndex) otherCard.classList.add('hover-focus'); else if (otherIndex < hoveredIndex) otherCard.classList.add('look-right'); else otherCard.classList.add('look-left'); }); }); hoveredCard.addEventListener('mouseleave', () => { if (isAnimating) return; cards.forEach(card => card.classList.remove('hover-focus', 'look-left', 'look-right')); }); }); cards.forEach(clickedCard => { const clickHandler = () => { if (isAnimating) return; isAnimating = true; this.audio.play('cardPickup'); cards.forEach(c => c.classList.remove('hover-focus', 'look-left', 'look-right')); clickedCard.classList.add('selected'); cards.forEach(otherCard => { if (otherCard !== clickedCard) otherCard.classList.add('exploding'); }); this.player.applyUpgrade(clickedCard.dataset.upgradeId); setTimeout(() => { clickedCard.classList.add('exit-down'); setTimeout(() => { elements.levelUpScreen.classList.add('hidden'); cards.forEach(card => card.classList.remove('selected', 'exploding', 'exit-down')); this.gameState = this.bossActive ? 'bossWave' : 'playing'; this.lastTime = performance.now(); }, 1000); }, 1800); clickedCard.removeEventListener('click', clickHandler); elements.rerollButton.removeEventListener('click', rerollHandler); }; clickedCard.addEventListener('click', clickHandler); }); }
            }
        });
    </script>
</body>
</html>
