<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seraph's Last Stand</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=VT323&display=swap" rel="stylesheet">

    <style>
        @keyframes pulse-title { 0%, 100% { transform: scale(1); text-shadow: 4px 4px 0 #5a4a00, 0 0 30px rgba(255, 199, 0, 0.3); } 50% { transform: scale(1.05); text-shadow: 6px 6px 5px #5a4a00, 0 0 50px rgba(255, 199, 0, 0.6); } }
        @keyframes pulse-red { 0%, 100% { transform: scale(1); text-shadow: 2px 2px 0 #330000; } 50% { transform: scale(1.02); text-shadow: 3px 3px 3px #550000; } }
        @keyframes screen-shake { 0%, 100% { transform: translate(0, 0); } 25% { transform: translate(-3px, 3px); } 50% { transform: translate(3px, -3px); } 75% { transform: translate(-3px, -3px); } }

        :root { --border-color: #FFF; --text-color: #FFF; --bg-color: #000; --dark-bg-color: #111; --accent-color: #e6b800; --border-radius: 0px; }

        body { background-color: var(--dark-bg-color); color: var(--text-color); font-family: 'VT323', monospace; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; overflow: hidden; transition: background-image 0.5s ease; }
        #gameContainer { position: relative; width: 100%; max-width: 1280px; aspect-ratio: 16 / 9; background-color: #000; border: 4px solid var(--border-color); box-sizing: border-box; transition: transform 0.1s, border-radius 0.5s ease; border-radius: var(--border-radius); }
        #gameContainer.shake { animation: screen-shake 0.1s linear 1; }
        #gameCanvas {
            width: 100%; height: 100%;
            image-rendering: pixelated;
            position: absolute; top: 0; left: 0;
            z-index: 1;
            border-radius: var(--border-radius);
            /* --- NOVO: Cursor Personalizado --- */
            cursor: url('cursor.png') 0 0, auto;
        }
        
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.8); transition: opacity 0.5s ease, backdrop-filter 0.5s ease; z-index: 10; text-align: center; border-radius: var(--border-radius); }
        .overlay.hidden { opacity: 0; pointer-events: none; }
        
        #startScreen { background: radial-gradient(circle at 50% 50%, #1a1a1a, #000); }
        #startScreen h1 { font-family: 'Cinzel', serif; font-size: clamp(3rem, 10vw, 6rem); line-height: 1.1; margin: 0; color: var(--accent-color); animation: pulse-title 5s ease-in-out infinite; }
        .start-button { font-family: 'VT323', monospace; background: none; color: var(--text-color); cursor: pointer; border: 4px solid var(--border-color); box-shadow: 0 0 0 2px var(--bg-color), 0 0 0 4px var(--border-color); background-color: var(--bg-color); padding: 15px 50px; font-size: 2.5rem; transition: all 0.3s ease; border-radius: var(--border-radius); }
        .start-button:hover:not(:disabled) { color: var(--accent-color); border-color: var(--accent-color); box-shadow: 0 0 0 2px var(--bg-color), 0 0 0 4px var(--accent-color), 0 0 20px var(--accent-color); transform: scale(1.05); }
        .start-button:disabled { color: #666; border-color: #666; cursor: not-allowed; }
        .menu-character { margin: 20px 0; image-rendering: pixelated; width: 64px; height: 128px; }
        .main-menu-buttons { display: flex; flex-direction: column; gap: 10px; }

        .overlay-menu-button { margin: 10px; width: 250px; }

        #gameOverScreen { background-color: rgba(30, 0, 0, 0.8); }
        #gameOverScreen h2 { font-family: 'Cinzel', serif; font-size: 6rem; color: #d44; margin: 0; animation: pulse-red 2s ease-in-out infinite; }
        #gameOverScreen p { font-size: 2.5rem; margin: 20px 0; }
        #highScoreText { color: var(--accent-color); font-size: 1.8rem; }
        #retryButton { font-family: 'VT323', monospace; font-size: 2rem; color: #ccc; border: 4px solid #ccc; background-color: #222; padding: 10px 40px; cursor: pointer; transition: all 0.2s ease; border-radius: var(--border-radius); }
        #retryButton:hover { color: #fff; border-color: #fff; background-color: #444; transform: scale(1.05); }
        
        #hud { position: absolute; top: 20px; left: 20px; z-index: 5; width: 30%; max-width: 350px; font-size: 1.2rem; display: flex; flex-direction: column; gap: 5px;}
        .hud-item { display: flex; align-items: center; gap: 10px; }
        .bar-container { flex-grow: 1; height: 20px; background-color: rgba(0, 0, 0, 0.4); border: 2px solid #fff; box-sizing: border-box; border-radius: var(--border-radius); overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.3s ease-out; }
        #hp-bar { background-color: #c0392b; } #exp-bar { background-color: #2980b9; }

        #pauseScreen .pause-content { display: flex; justify-content: space-around; width: 80%; max-width: 900px; margin-top: 1rem; align-items: flex-start; }
        .pause-column { background-color: rgba(0,0,0,0.5); border: 2px solid #555; padding: 1.5rem; width: 45%; border-radius: var(--border-radius); }
        .pause-column h3 { font-family: 'Cinzel', serif; font-size: 1.8rem; margin-top: 0; margin-bottom: 1rem; color: var(--accent-color); text-shadow: 2px 2px #333; }
        #pauseStats p { font-size: 1.1rem; margin: 5px 0; text-align: left; }
        #pauseUpgrades .upgrade-item { font-size: 1rem; padding: 5px 10px; margin-bottom: 5px; border-left: 5px solid; text-align: left; }
        .upgrade-item.common { border-color: #ccc; color: #ccc; } .upgrade-item.uncommon { border-color: #55ff55; color: #55ff55; } .upgrade-item.rare { border-color: #8855ff; color: #8855ff; }

        #levelUpScreen { backdrop-filter: blur(5px); }
        #levelUpScreen h2 { font-family: 'Cinzel', serif; font-size: 3rem; margin-bottom: 2rem; color: #fff; text-shadow: 3px 3px #333; }
        .card-container { display: flex; gap: 20px; perspective: 1200px; margin-bottom: 2rem; }
        #rerollButton { font-size: 1.5rem; padding: 10px 30px; }

        .card { width: 170px; height: 250px; background-color: #000; border: 3px solid #444; cursor: pointer; position: relative; padding: 15px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; transition: transform 0.6s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.6s ease, border-color 0.4s ease; transform-style: preserve-3d; border-radius: var(--border-radius); }
        .card-title { font-family: 'Cinzel', serif; margin: 0 0 10px 0; font-size: 1.1rem; color: #fff; }
        .card.common .card-title { color: #fff; } .card.uncommon .card-title { color: #55ff55; } .card.rare .card-title { color: #8855ff; }
        .card-icon { width: 90px; height: 90px; border: 3px solid #ccc; margin-bottom: 15px; display: flex; justify-content: center; align-items: center; background-color: #111; font-size: 3rem; color: white; border-radius: var(--border-radius); }
        .card-description { color: #ddd; text-align: center; font-size: 0.9rem; line-height: 1.3; }
        .card.hover-focus { transform: translateY(-25px) scale(1.1); border-color: #66ff66; z-index: 101; }
        .card.look-left { transform: rotateY(-20deg) scale(0.95); } .card.look-right { transform: rotateY(20deg) scale(0.95); }
        .card.selected { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(1.25); border-color: #ffa500; z-index: 100; }
        .card.exploding { opacity: 0; pointer-events: none; }
        .card.exploding:nth-of-type(odd) { transform: translate(-60vw, -110vh) rotate(-480deg) scale(0); }
        .card.exploding:nth-of-type(even) { transform: translate(60vw, 110vh) rotate(480deg) scale(0); }
        .card.exploding:nth-of-type(3n) { transform: translate(0, 120vh) rotate(360deg) scale(0); }
        .card.selected.exit-down { transition-timing-function: cubic-bezier(0.16, 1, 0.3, 1); transform: translate(-50%, 150vh) scale(1.25); }

        #settingsScreen .settings-container, #achievementsScreen .achievements-container { display: flex; flex-direction: column; gap: 1.5rem; background: rgba(0,0,0,0.6); border: 2px solid #555; padding: 2rem; width: 60%; max-width: 600px; border-radius: var(--border-radius); }
        .setting-item { display: flex; justify-content: space-between; align-items: center; font-size: 1.5rem; }
        .setting-item input[type="range"] { width: 50%; } .setting-item input[type="checkbox"] { width: 25px; height: 25px; cursor: pointer; }

        #achievementsScreen .achievements-container { max-height: 70vh; overflow-y: auto; }
        .achievement-item { display: flex; align-items: center; padding: 10px; background-color: #222; margin-bottom: 10px; border-left: 5px solid #555; transition: all 0.3s ease; border-radius: var(--border-radius); }
        .achievement-item.unlocked { background-color: #4a4a2a; border-left-color: var(--accent-color); }
        .achievement-icon { font-size: 2.5rem; width: 50px; text-align: center; margin-right: 15px; }
        .achievement-details { text-align: left; }
        .achievement-details h4 { margin: 0; font-size: 1.2rem; }
        .achievement-details p { margin: 0; font-size: 1rem; color: #aaa; }
        .achievement-item.unlocked .achievement-details h4 { color: var(--accent-color); }
        .achievement-item.unlocked .achievement-details p { color: #eee; }

        body.frutiger-aero-active { background-image: url('background.png'); background-size: cover; background-position: center; }
        body.frutiger-aero-active { --border-radius: 15px; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="hud"><div class="hud-item"><span id="hpText">HP: 100/100</span><div class="bar-container"><div id="hp-bar" class="bar-fill"></div></div></div><div class="hud-item"><span id="expText">LVL: 1</span><div class="bar-container"><div id="exp-bar" class="bar-fill"></div></div></div></div>
        <canvas id="gameCanvas"></canvas>
        <div id="startScreen" class="overlay">
            <h1>SERAPH'S<br>LAST STAND</h1>
            <img id="menuCharacterImg" class="menu-character" alt="Wizard Character">
            <div class="main-menu-buttons">
                <button id="startButton" class="start-button" disabled>LOADING...</button>
                <button id="achievementsButtonMain" class="start-button overlay-menu-button" style="font-size: 1.5rem; padding: 10px 30px;">Achievements</button>
                <button id="settingsButtonMain" class="start-button overlay-menu-button" style="font-size: 1.5rem; padding: 10px 30px;">Settings</button>
            </div>
        </div>
        <div id="pauseScreen" class="overlay hidden">
            <h1>PAUSED</h1><div class="pause-content"><div class="pause-column" id="pauseStats"><h3>Player Stats</h3></div><div class="pause-column" id="pauseUpgrades"><h3>Current Upgrades</h3></div></div>
            <button id="continueButton" class="start-button overlay-menu-button">Continue</button><button id="settingsButtonPause" class="start-button overlay-menu-button" style="font-size: 1.5rem; padding: 10px 30px;">Settings</button><button id="newGameButton" class="start-button overlay-menu-button">New Game</button>
        </div>
        <div id="levelUpScreen" class="overlay hidden"><h2>Choose a Card</h2><div class="card-container"></div><button id="rerollButton" class="start-button">Reroll</button></div>
        <div id="gameOverScreen" class="overlay hidden"><h2>GAME OVER</h2><p id="scoreText">Score: 0</p><p id="highScoreText">High Score: 0</p><button id="retryButton">Retry</button></div>
        <div id="settingsScreen" class="overlay hidden">
            <h1>Settings</h1><div class="settings-container"><div class="setting-item"><label for="musicVolume">Music Volume</label><input type="range" id="musicVolume" min="0" max="1" step="0.05"></div><div class="setting-item"><label for="sfxVolume">SFX Volume</label><input type="range" id="sfxVolume" min="0" max="1" step="0.05"></div><div class="setting-item"><label for="cameraSmoothingCheckbox">Smooth Camera</label><input type="checkbox" id="cameraSmoothingCheckbox"></div><div class="setting-item"><label for="showDamageNumbersCheckbox">Show Damage</label><input type="checkbox" id="showDamageNumbersCheckbox"></div><div class="setting-item"><label for="bloomEffectCheckbox">Bloom Effect</label><input type="checkbox" id="bloomEffectCheckbox"></div><div class="setting-item"><label for="frutigerAeroCheckbox">Frutiger Aero</label><input type="checkbox" id="frutigerAeroCheckbox"></div></div>
            <button id="closeSettingsButton" class="start-button overlay-menu-button" style="margin-top: 2rem;">Back</button>
        </div>
        <div id="achievementsScreen" class="overlay hidden">
            <h1>Achievements</h1><div class="achievements-container"></div>
            <button id="closeAchievementsButton" class="start-button overlay-menu-button" style="margin-top: 2rem;">Back</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const elements = { gameContainer: document.getElementById('gameContainer'), canvas: document.getElementById('gameCanvas'), startScreen: document.getElementById('startScreen'), startButton: document.getElementById('startButton'), menuCharacterImg: document.getElementById('menuCharacterImg'), pauseScreen: document.getElementById('pauseScreen'), continueButton: document.getElementById('continueButton'), newGameButton: document.getElementById('newGameButton'), levelUpScreen: document.getElementById('levelUpScreen'), gameOverScreen: document.getElementById('gameOverScreen'), retryButton: document.getElementById('retryButton'), scoreText: document.getElementById('scoreText'), highScoreText: document.getElementById('highScoreText'), hpBar: document.getElementById('hp-bar'), expBar: document.getElementById('exp-bar'), hpText: document.getElementById('hpText'), expText: document.getElementById('expText'), rerollButton: document.getElementById('rerollButton'), settingsScreen: document.getElementById('settingsScreen'), settingsButtonMain: document.getElementById('settingsButtonMain'), settingsButtonPause: document.getElementById('settingsButtonPause'), closeSettingsButton: document.getElementById('closeSettingsButton'), musicVolumeSlider: document.getElementById('musicVolume'), sfxVolumeSlider: document.getElementById('sfxVolume'), cameraSmoothingCheckbox: document.getElementById('cameraSmoothingCheckbox'), showDamageNumbersCheckbox: document.getElementById('showDamageNumbersCheckbox'), bloomEffectCheckbox: document.getElementById('bloomEffectCheckbox'), frutigerAeroCheckbox: document.getElementById('frutigerAeroCheckbox'), achievementsScreen: document.getElementById('achievementsScreen'), achievementsButtonMain: document.getElementById('achievementsButtonMain'), closeAchievementsButton: document.getElementById('closeAchievementsButton') };
            const ctx = elements.canvas.getContext('2d'); let animationFrameId; let game;

            class SettingsManager { constructor() { this.defaults = { musicVolume: 0.3, sfxVolume: 0.5, cameraSmoothing: true, showDamageNumbers: true, bloom: true, frutigerAero: false, highScore: 0, totalKills: 0, totalDeaths: 0, unlockedAchievements: [] }; this.settings = this.load(); } load() { const saved = localStorage.getItem('seraphsLastStandSettings'); return saved ? { ...this.defaults, ...JSON.parse(saved) } : this.defaults; } save() { localStorage.setItem('seraphsLastStandSettings', JSON.stringify(this.settings)); } get(key) { return this.settings[key]; } set(key, value) { this.settings[key] = value; this.save(); } }
            const settings = new SettingsManager();
            
            const achievements = {
                'kill_10': { name: 'Novice Slayer', description: 'Defeat 10 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 10 }, 'kill_50': { name: 'Adept Slayer', description: 'Defeat 50 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 50 }, 'kill_100': { name: 'Expert Slayer', description: 'Defeat 100 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 100 }, 'kill_250': { name: 'Master Slayer', description: 'Defeat 250 enemies.', icon: 'üíÄ', check: () => settings.get('totalKills') >= 250 }, 'death_1': { name: 'First of Many', description: 'Die for the first time.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 1 }, 'death_5': { name: 'Getting Used To It', description: 'Die 5 times.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 5 }, 'death_10': { name: 'Persistent', description: 'Die 10 times.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 10 }, 'death_100': { name: 'Why Are We Still Here?', description: 'Die 100 times.', icon: 'üíî', check: () => settings.get('totalDeaths') >= 100 }, 'rare_card': { name: 'A Rare Find', description: 'Obtain a Rare upgrade.', icon: 'üíé', check: (g) => g.player.collectedUpgrades.some(id => upgrades[id]?.rarity === 'rare') }, 'frutiger_aero': { name: 'Sonho do Andrezitos?', description: 'Discover a more... glossy reality.', icon: 'üíß', check: () => settings.get('frutigerAero') }
            };

            const assetPaths = { images: { player: 'mago.png', enemy: 'inimigo.png', eye: 'eye.png', demon: 'demon.png' }, sounds: { soundtrack: 'soundtrack.mp3', menu: 'menu.mp3', bullet: 'bullet.mp3', jump: 'pulo.mp3', playerDamage: 'playerdamage.mp3', playerDeath: 'playerdeathsound.mp3', enemyDeath: 'enemiedeathsound.mp3', cardPickup: 'cardpickup.mp3', click: 'click.mp3' } };
            class AssetLoader { constructor(paths) { this.paths = paths; this.images = {}; this.sounds = {}; } load(onProgress) { const imagePromises = Object.entries(this.paths.images).map(([key, path]) => new Promise((resolve) => { const img = new Image(); img.src = path; img.onload = () => { this.images[key] = img; onProgress(); resolve(); }; img.onerror = () => { onProgress(); resolve(); }; })); const soundPromises = Object.entries(this.paths.sounds).map(([key, path]) => new Promise((resolve) => { const audio = new Audio(path); const canPlayHandler = () => { this.sounds[key] = audio; onProgress(); audio.removeEventListener('canplaythrough', canPlayHandler); resolve(); }; audio.addEventListener('canplaythrough', canPlayHandler); audio.onerror = () => { onProgress(); resolve(); }; audio.load(); })); return Promise.all([...imagePromises, ...soundPromises]); } }
            class AudioManager { constructor(sounds) { this.sounds = sounds; this.currentMusic = null; } play(soundName, volumeMultiplier = 1) { if (this.sounds[soundName]) { const sound = this.sounds[soundName].cloneNode(); sound.volume = settings.get('sfxVolume') * volumeMultiplier; sound.play().catch(e => {}); } } startMusic(track) { this.stopAllMusic(); if (this.sounds[track]) { this.currentMusic = this.sounds[track]; this.currentMusic.loop = true; this.currentMusic.volume = settings.get('musicVolume'); this.currentMusic.play().catch(e => {}); } } stopAllMusic() { if(this.currentMusic) { this.currentMusic.pause(); this.currentMusic.currentTime = 0; } this.currentMusic = null; } updateMusicVolume() { if(this.currentMusic) { this.currentMusic.volume = settings.get('musicVolume'); } } }
            
            function resizeCanvas() { const containerRect = elements.gameContainer.getBoundingClientRect(); elements.canvas.width = containerRect.width; elements.canvas.height = containerRect.height; if (game) { game.width = elements.canvas.width; game.height = elements.canvas.height; game.createStars(); } }
            let globalAssetLoader;
            function onAssetsLoaded(assetLoader) { globalAssetLoader = assetLoader; elements.startButton.disabled = false; elements.startButton.textContent = "START"; elements.menuCharacterImg.src = assetLoader.images.player.src; const menuAudio = new AudioManager(assetLoader.sounds); menuAudio.startMusic('menu'); }
            const totalAssets = Object.keys(assetPaths.images).length + Object.keys(assetPaths.sounds).length; let loadedAssets = 0;
            const assetLoader = new AssetLoader(assetPaths); assetLoader.load(() => { loadedAssets++; elements.startButton.textContent = `LOADING... ${Math.round((loadedAssets / totalAssets) * 100)}%`; }).then(() => onAssetsLoaded(assetLoader));
            function startGame() { if (elements.startButton.disabled) return; new AudioManager(globalAssetLoader.sounds).play('click'); elements.startScreen.classList.add('hidden'); elements.gameOverScreen.classList.add('hidden'); game = new Game(elements.canvas.width, elements.canvas.height, globalAssetLoader); game.audio.startMusic('soundtrack'); if(animationFrameId) cancelAnimationFrame(animationFrameId); gameLoop(); }
            function gameLoop(timestamp) { if(game && game.gameState !== 'gameOver') { if (game.gameState === 'playing') { ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height); game.update(timestamp); game.draw(ctx); } animationFrameId = requestAnimationFrame(gameLoop); } }
            
            function applyFrutigerAero() { document.body.classList.toggle('frutiger-aero-active', settings.get('frutigerAero')); }
            function setupSettingsUI() { elements.musicVolumeSlider.value = settings.get('musicVolume'); elements.sfxVolumeSlider.value = settings.get('sfxVolume'); elements.cameraSmoothingCheckbox.checked = settings.get('cameraSmoothing'); elements.showDamageNumbersCheckbox.checked = settings.get('showDamageNumbers'); elements.bloomEffectCheckbox.checked = settings.get('bloom'); elements.frutigerAeroCheckbox.checked = settings.get('frutigerAero'); const toggleSettings = () => elements.settingsScreen.classList.toggle('hidden'); elements.settingsButtonMain.addEventListener('click', toggleSettings); elements.settingsButtonPause.addEventListener('click', toggleSettings); elements.closeSettingsButton.addEventListener('click', () => { if(game && game.audio) game.audio.play('click'); toggleSettings(); }); elements.musicVolumeSlider.addEventListener('input', (e) => { settings.set('musicVolume', parseFloat(e.target.value)); if(game && game.audio) game.audio.updateMusicVolume(); else if (globalAssetLoader) new AudioManager(globalAssetLoader.sounds).updateMusicVolume(); }); elements.sfxVolumeSlider.addEventListener('input', (e) => settings.set('sfxVolume', parseFloat(e.target.value))); elements.cameraSmoothingCheckbox.addEventListener('change', (e) => settings.set('cameraSmoothing', e.target.checked)); elements.showDamageNumbersCheckbox.addEventListener('change', (e) => settings.set('showDamageNumbers', e.target.checked)); elements.bloomEffectCheckbox.addEventListener('change', (e) => settings.set('bloom', e.target.checked)); elements.frutigerAeroCheckbox.addEventListener('change', (e) => { settings.set('frutigerAero', e.target.checked); applyFrutigerAero(); if(game) game.checkAchievements(); }); applyFrutigerAero(); }
            function setupAchievementsUI() { const toggleAchievements = () => elements.achievementsScreen.classList.toggle('hidden'); elements.achievementsButtonMain.addEventListener('click', () => { populateAchievementsScreen(); toggleAchievements(); }); elements.closeAchievementsButton.addEventListener('click', toggleAchievements); }
            function populateAchievementsScreen() { const container = elements.achievementsScreen.querySelector('.achievements-container'); container.innerHTML = ''; const unlocked = settings.get('unlockedAchievements'); for (const id in achievements) { const ach = achievements[id]; const isUnlocked = unlocked.includes(id); container.innerHTML += `<div class="achievement-item ${isUnlocked ? 'unlocked' : ''}"><span class="achievement-icon">${isUnlocked ? ach.icon : '‚ùì'}</span><div class="achievement-details"><h4>${isUnlocked ? ach.name : '??????'}</h4><p>${isUnlocked ? ach.description : 'Keep playing to unlock!'}</p></div></div>`; } }
            setupSettingsUI(); setupAchievementsUI();

            elements.startButton.addEventListener('click', startGame); elements.retryButton.addEventListener('click', () => { new AudioManager(globalAssetLoader.sounds).play('click'); location.reload(); }); elements.continueButton.addEventListener('click', () => game.togglePause()); elements.newGameButton.addEventListener('click', () => { game.audio.play('click'); location.reload(); });
            resizeCanvas();

            const upgrades = { 'Growth': { name: 'Growth', rarity: 'common', description: 'Max. HP +10', effect: (p) => { p.maxHp += 10; p.hp += 10; }}, 'Resist': { name: 'Resist', rarity: 'common', description: 'Defense +4%', effect: (p) => { p.defense += 0.04; }}, 'Swift': { name: 'Swift', rarity: 'common', description: 'Movement Speed +20%', effect: (p) => { p.speedModifier += 0.2; }}, 'Catalyst': { name: 'Catalyst', rarity: 'common', description: 'Projectile Damage +2', effect: (p) => { p.projectileDamage += 2; }}, 'Resonance': { name: 'Resonance', rarity: 'common', description: 'Atk Speed +12%', effect: (p) => { p.attackSpeedModifier += 0.12; }}, 'Eyesight': { name: 'Eyesight', rarity: 'common', description: 'Critical Chance +5%', effect: (p) => { p.critChance += 0.05; }}, 'Impulse': { name: 'Impulse', rarity: 'common', description: 'Jump Height +30%', effect: (p) => { p.jumpModifier += 0.3; }}, 'Renew': { name: 'Renew', rarity: 'common', description: 'Heal to Max. HP', effect: (p) => { p.hp = p.maxHp; }}, 'Orb': { name: 'Orb', rarity: 'uncommon', description: 'Enemies have a 5% chance to drop a healing orb (+10 HP).', effect: (p) => { p.upgrades.healingOrbChance = (p.upgrades.healingOrbChance || 0) + 0.05; }}, 'Precision': { name: 'Precision', rarity: 'uncommon', description: 'Critical deals +50% damage', effect: (p) => { p.critDamageModifier += 0.5; }}, 'Growth+': { name: 'Growth+', rarity: 'uncommon', description: 'Max. HP +20', effect: (p) => { p.maxHp += 20; p.hp += 20; }}, 'Fragmentation': { name: 'Fragmentation', rarity: 'uncommon', description: 'Enemies explode into 2 projectiles on death.', effect: (p) => { p.upgrades.fragmentation = (p.upgrades.fragmentation || 0) + 2; }}, 'Leech': { name: 'Leech', rarity: 'uncommon', description: 'Life Steal of 3% Damage', effect: (p) => { p.lifesteal = (p.lifesteal || 0) + 0.03; }}, 'Swift+': { name: 'Swift+', rarity: 'uncommon', description: 'Movement Speed +40%', effect: (p) => { p.speedModifier += 0.4; }}, 'Thunderbolt': { name: 'Thunderbolt', rarity: 'rare', description: 'Calls 2 thunderbolts from the sky every few seconds.', effect: (p) => { if(!p.upgrades.thunderbolt) p.upgrades.thunderbolt = { count: 0, interval: 4000, timer: 4000 }; p.upgrades.thunderbolt.count += 2; }}, 'Overheat': { name: 'Overheat', rarity: 'rare', description: 'Your body deals 40 damage on contact', effect: (p) => { if(!p.upgrades.overheat) p.upgrades.overheat = { damage: 0 }; p.upgrades.overheat.damage += 40; }}, 'Barrier': { name: 'Barrier', rarity: 'rare', description: 'Creates a shield that blocks damage once every few seconds.', effect: (p) => { if(!p.upgrades.barrier) p.upgrades.barrier = { ready: true, cooldown: 8000, timer: 8000 }; else p.upgrades.barrier.cooldown *= 0.9; }}, 'Friction': { name: 'Friction', rarity: 'uncommon', description: 'For every meter you run, 1 explosive projectile is launched upwards.', effect: (p) => { p.upgrades.friction = (p.upgrades.friction || 0) + 1; }}, 'Wound': { name: 'Wound', rarity: 'rare', description: 'Dealing damage applies bleeding to the enemy.', effect: (p) => { p.upgrades.wound = true; }}, 'Cold': { name: 'Cold', rarity: 'rare', description: 'Enemies get 1% slower every time they take damage (up to 80%).', effect: (p) => { p.upgrades.cold = (p.upgrades.cold || 0) + 0.01; }},};
            const inputHandler = { keys: new Set(), mouse: { x: 0, y: 0, down: false }, init() { window.addEventListener('keydown', e => { this.keys.add(e.code); if (e.code === 'Escape' && game && (game.gameState === 'playing' || game.gameState === 'paused')) game.togglePause(); }); window.addEventListener('keyup', e => this.keys.delete(e.code)); elements.canvas.addEventListener('mousemove', e => { const rect = elements.canvas.getBoundingClientRect(); this.mouse.x = e.clientX - rect.left; this.mouse.y = e.clientY - rect.top; }); elements.canvas.addEventListener('mousedown', () => this.mouse.down = true); elements.canvas.addEventListener('mouseup', () => this.mouse.down = false); } };
            inputHandler.init();
            
            class Player { constructor(game) { this.game = game; this.width = 32; this.height = 64; this.x = this.game.width / 2; this.y = this.game.height - this.height - 40; this.vx = 0; this.vy = 0; this.onGround = false; this.jumpsLeft = 2; this.maxJumps = 2; this.image = this.game.assets.images.player; this.staffAngle = 0; this.staffLength = 40; this.maxHp = 100; this.hp = this.maxHp; this.level = 1; this.exp = 0; this.expToNextLevel = 2; this.defense = 0; this.speedModifier = 1; this.jumpModifier = 1; this.projectileDamage = 5; this.attackSpeedModifier = 1; this.critChance = 0.05; this.critDamageModifier = 1.5; this.lifesteal = 0; this.upgradeChoices = 3; this.upgrades = {}; this.collectedUpgrades = []; this.shootCooldown = 500; this.lastShotTime = 0; this.isInvincible = false; this.invincibilityDuration = 500; this.invincibilityTimer = 0; this.distanceMoved = 0; this.statusEffects = { burn: { active: false, duration: 0, damagePerSecond: 0 } }; } draw(ctx) { ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2 - 10); ctx.rotate(this.staffAngle); ctx.fillStyle = '#654321'; ctx.fillRect(0, -2, this.staffLength, 4); if (settings.get('bloom')) { ctx.shadowBlur = 15; ctx.shadowColor = '#00FFFF'; } ctx.fillStyle = '#00FFFF'; ctx.beginPath(); ctx.arc(this.staffLength, 0, 8, 0, Math.PI * 2); ctx.fill(); ctx.restore(); if (this.statusEffects.burn.active) { for(let i=0; i<3; i++) this.game.particles.push(new Particle(this.game, this.x + Math.random() * this.width, this.y + Math.random() * this.height, 'orange', 0.5)); } ctx.globalAlpha = this.isInvincible ? 0.5 : 1.0; if(this.image?.complete) ctx.drawImage(this.image, this.x, this.y, this.width, this.height); ctx.globalAlpha = 1.0; if (this.upgrades.barrier?.ready) { if(settings.get('bloom')) { ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(100, 150, 255, 0.8)'; } ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.height/2 + 5, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur=0; } } update(input, deltaTime) { this.updateStatusEffects(deltaTime); const baseSpeed = 5; this.vx = 0; if (input.keys.has('KeyA')) this.vx = -baseSpeed * this.speedModifier; if (input.keys.has('KeyD')) this.vx = baseSpeed * this.speedModifier; this.x += this.vx; if(this.onGround && this.vx !== 0) this.distanceMoved += Math.abs(this.vx); this.vy += this.game.gravity; this.y += this.vy; this.onGround = false; this.game.platforms.forEach(platform => { if (this.x < platform.x + platform.width && this.x + this.width > platform.x && this.y < platform.y + platform.height && this.y + this.height > platform.y && this.vy >= 0 && this.y + this.height - this.vy <= platform.y) { this.onGround = true; this.jumpsLeft = this.maxJumps; this.y = platform.y - this.height; this.vy = 0; } }); if (this.x < 0) this.x = 0; if (this.x + this.width > this.game.width) this.x = this.game.width - this.width; if (this.isInvincible) { this.invincibilityTimer -= deltaTime; if (this.invincibilityTimer <= 0) this.isInvincible = false; } this.staffAngle = Math.atan2(input.mouse.y - (this.y + this.height / 2 - 10) + this.game.cameraY, input.mouse.x - (this.x + this.width / 2) + this.game.cameraX); if (input.mouse.down && Date.now() - this.lastShotTime > this.shootCooldown / this.attackSpeedModifier) { this.shoot(); this.lastShotTime = Date.now(); } } updateStatusEffects(deltaTime) { const burn = this.statusEffects.burn; if(burn.active) { burn.duration -= deltaTime; if(burn.duration <= 0) { burn.active = false; } else { this.hp -= burn.damagePerSecond * (deltaTime / 1000); if(this.hp <= 0) { this.hp = 0; this.game.gameOver(); } } } } applyBurn() { const burn = this.statusEffects.burn; burn.active = true; burn.duration = 3000; burn.damagePerSecond = this.maxHp * 0.05; } jump() { if (this.jumpsLeft > 0) { this.game.audio.play('jump'); this.vy = -12 * this.jumpModifier; this.jumpsLeft--; this.onGround = false; } } shoot() { this.game.audio.play('bullet'); const startX = this.x + this.width / 2 + Math.cos(this.staffAngle) * this.staffLength; const startY = this.y + this.height / 2 - 10 + Math.sin(this.staffAngle) * this.staffLength; this.game.projectiles.push(new Projectile(this.game, startX, startY, this.staffAngle, this)); } takeDamage(damage) { if (this.isInvincible) return; if (this.upgrades.barrier?.ready) { this.upgrades.barrier.ready = false; this.isInvincible = true; this.invincibilityTimer = 300; this.game.audio.play('playerDamage', 0.2); return; } this.game.audio.play('playerDamage'); this.hp -= Math.max(1, damage * (1 - this.defense)); this.isInvincible = true; this.invincibilityTimer = this.invincibilityDuration; this.game.triggerScreenShake(); if (this.hp <= 0) { this.hp = 0; this.game.gameOver(); } } gainExp(killCount = 1) { this.exp += killCount; if (this.exp >= this.expToNextLevel) { this.level++; this.exp = 0; this.expToNextLevel = 2 + this.level; this.game.levelUp(); } } applyUpgrade(upgradeId) { const upgrade = upgrades[upgradeId]; if(upgrade && upgrade.effect) { upgrade.effect(this); this.collectedUpgrades.push(upgradeId); } this.game.checkAchievements(); } }
            class Enemy { constructor(game, playerLevel, type = 'basic') { this.game = game; this.type = type; const scaleFactor = 1 + Math.min((playerLevel - 1) * 0.1, 1.5); this.x = Math.random() * (game.width - 40); this.y = -50; this.state = 'descending'; this.targetY = game.enemyKeepAwayY + Math.random() * (game.height * 0.2); this.markedForDeletion = false; this.angle = 0; this.statusEffects = { bleed: { damage: 0, duration: 0 }, cold: { amount: 0, duration: 0 } }; switch(this.type) { case 'eye': this.image = this.game.assets.images.eye; this.width = 42 * scaleFactor; this.height = 37 * scaleFactor; this.speed = 0.8 + Math.random() * 0.4 + game.wave * 0.03; this.maxHp = (8 + game.wave * 1.5) * scaleFactor; this.damage = (4 + game.wave * 0.8) * scaleFactor; this.shootCooldown = Math.max(600, 2000 - game.wave * 35); this.expValue = Math.floor(1 * scaleFactor); break; case 'demon': this.image = this.game.assets.images.demon; this.width = 36 * scaleFactor; this.height = 34 * scaleFactor; this.speed = 0.6 + Math.random() * 0.2 + game.wave * 0.02; this.maxHp = (40 + game.wave * 6) * scaleFactor; this.damage = (8 + game.wave * 1.2) * scaleFactor; this.shootCooldown = Math.max(2000, 4500 - game.wave * 60); this.expValue = Math.floor(4 * scaleFactor); break; default: this.image = this.game.assets.images.enemy; this.width = 32 * scaleFactor; this.height = 19 * scaleFactor; this.speed = 1 + Math.random() * 0.5 + game.wave * 0.05; this.maxHp = (10 + game.wave * 2) * scaleFactor; this.damage = (5 + game.wave) * scaleFactor; this.shootCooldown = Math.max(800, 2500 - game.wave * 40); this.expValue = Math.floor(1 * scaleFactor); break; } this.hp = this.maxHp; this.lastShotTime = Date.now() + Math.random() * 1000; } draw(ctx) { ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.angle); if(this.image?.complete) ctx.drawImage(this.image, -this.width/2, -this.height/2, this.width, this.height); ctx.restore(); if(this.hp < this.maxHp) { ctx.fillStyle = 'rgba(255,0,0,0.7)'; ctx.fillRect(this.x, this.y - 8, this.width, 4); ctx.fillStyle = 'rgba(0,255,0,0.7)'; ctx.fillRect(this.x, this.y - 8, this.width * (this.hp/this.maxHp), 4); } } update(player, otherEnemies, deltaTime) { let currentSpeed = this.speed * (1 - this.statusEffects.cold.amount); if (this.state === 'descending') { this.y += currentSpeed; if (this.y >= this.targetY) this.state = 'following'; } else if (this.state === 'following') { const dx = player.x - this.x; const dy = player.y - this.y; this.angle = Math.atan2(dy, dx) + Math.PI / 2; this.x += dx * 0.01 * currentSpeed; this.y += dy * 0.01 * currentSpeed; this.y = Math.max(this.y, this.game.enemyKeepAwayY); if (Date.now() - this.lastShotTime > this.shootCooldown) { this.shoot(player); this.lastShotTime = Date.now(); } } otherEnemies.forEach(other => { if(this === other) return; const dist = Math.hypot(this.x - other.x, this.y - other.y); if (dist < this.width) { const angle = Math.atan2(this.y - other.y, this.x - other.x); this.x += Math.cos(angle) * (this.width - dist) / 2; this.y += Math.sin(angle) * (this.width - dist) / 2; } }); this.updateStatusEffects(deltaTime); } updateStatusEffects(deltaTime) { if (this.statusEffects.bleed.duration > 0) { this.takeDamage(this.statusEffects.bleed.damage * (deltaTime / 1000)); this.statusEffects.bleed.duration -= deltaTime; } if (this.statusEffects.cold.duration > 0) { this.statusEffects.cold.duration -= deltaTime; } else { this.statusEffects.cold.amount = 0; } } shoot(player) { const angle = Math.atan2(player.y - this.y, player.x - this.x); const projectileType = this.type === 'demon' ? 'fireball' : 'normal'; this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, angle, this, projectileType)); } takeDamage(amount, source) { this.hp -= amount; if (this.hp <= 0 && !this.markedForDeletion) { this.markedForDeletion = true; this.game.audio.play('enemyDeath'); this.game.createExplosion(this.x + this.width/2, this.y + this.height/2, this.width); if (source instanceof Player) { settings.set('totalKills', settings.get('totalKills') + 1); this.game.checkAchievements(); source.gainExp(this.expValue); if (source.upgrades.fragmentation) { for (let i = 0; i < source.upgrades.fragmentation; i++) this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, Math.random() * Math.PI * 2, source, 'fragment')); } if (source.upgrades.healingOrbChance && Math.random() < source.upgrades.healingOrbChance) { this.game.healingOrbs.push(new HealingOrb(this.game, this.x + this.width / 2, this.y + this.height / 2)); } } } } }
            class Projectile { constructor(game, x, y, angle, owner, type = 'normal') { this.game = game; this.x = x; this.y = y; this.owner = owner; this.type = type; let speed = (owner instanceof Player) ? 10 : 5; this.radius = 5; if (this.type === 'fragment') { this.damage = owner.projectileDamage * 0.5; this.color = '#add8e6'; speed = 7; this.radius=3; } else if (owner instanceof Player) { this.damage = owner.projectileDamage; this.color = 'cyan'; } else { this.damage = owner.damage; this.color = 'red'; } this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.markedForDeletion = false; this.trail = []; } draw(ctx) { ctx.save(); if (settings.get('bloom')) { ctx.shadowBlur = 10; ctx.shadowColor = this.color; } this.trail.forEach(t => { ctx.fillStyle = t.color; ctx.globalAlpha = t.alpha; ctx.beginPath(); ctx.arc(t.x, t.y, this.radius-2 > 0 ? this.radius-2 : 1, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0; if (this.type === 'fireball') { ctx.fillStyle = 'orange'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius + 3, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = 'yellow'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } else { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); } update() { this.trail.push({x: this.x, y: this.y, alpha: 1.0, color: this.color}); this.trail.forEach(t => t.alpha -= 0.08); this.trail = this.trail.filter(t => t.alpha > 0); this.x += this.vx; this.y += this.vy; if (this.x < -10 || this.x > this.game.width + 10 || this.y < -10 || this.y > this.game.height + 10) this.markedForDeletion = true; } }
            class HealingOrb { constructor(game, x, y) { this.game = game; this.x = x; this.y = y; this.vy = 0; this.radius = 8; this.markedForDeletion = false; this.bobAngle = Math.random() * Math.PI * 2; this.onGround = false; } update() { this.bobAngle += 0.1; if (!this.onGround) { this.vy += this.game.gravity * 0.5; this.y += this.vy; this.game.platforms.forEach(platform => { if (this.x > platform.x && this.x < platform.x + platform.width && this.y + this.radius > platform.y && this.y < platform.y + platform.height) { this.y = platform.y - this.radius; this.vy *= -0.4; if (Math.abs(this.vy) < 1) { this.onGround = true; this.vy = 0; } } }); } } draw(ctx) { const bobY = this.onGround ? Math.sin(this.bobAngle) * 3 : 0; ctx.save(); if(settings.get('bloom')) { ctx.shadowBlur = 15; ctx.shadowColor = '#33ff33'; } ctx.globalAlpha = 0.8; ctx.fillStyle = '#33ff33'; ctx.beginPath(); ctx.arc(this.x, this.y + bobY, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#ffffff'; ctx.stroke(); ctx.restore(); } }
            class DamageNumber { constructor(game, x, y, amount, isCrit) { this.game = game; this.x = x; this.y = y; this.text = Math.floor(amount); this.life = 1000; this.vy = -1; this.isCrit = isCrit; } update(deltaTime) { this.y += this.vy * (deltaTime/16); this.life -= deltaTime; if (this.life <= 0) this.markedForDeletion = true; } draw(ctx) { ctx.save(); ctx.globalAlpha = this.life / 1000; ctx.font = this.isCrit ? "24px VT323" : "18px VT323"; ctx.fillStyle = this.isCrit ? "yellow" : "white"; if(settings.get('bloom')) { ctx.shadowBlur = this.isCrit ? 10 : 5; ctx.shadowColor = this.isCrit ? "yellow" : "white"; } else { ctx.shadowColor = 'black'; ctx.shadowBlur = 4; } ctx.fillText(this.text, this.x, this.y); ctx.restore(); } }
            class Platform { constructor(x, y, width, height) { this.x = x; this.y = y; this.width = width; this.height = height; } draw(ctx) { const isAero = settings.get('frutigerAero'); ctx.fillStyle = isAero ? 'rgba(150, 200, 255, 0.2)' : 'transparent'; ctx.strokeStyle = isAero ? 'rgba(230, 245, 255, 0.7)' : '#fff'; ctx.lineWidth = isAero ? 3 : 2; if (isAero) ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); } }
            class Star { constructor(game) { this.game = game; this.parallax = Math.random() * 0.4 + 0.1; this.reset(); } reset() { this.x = Math.random() * this.game.width; this.y = Math.random() * this.game.height; this.size = Math.random() * 1.5 + 0.5; this.brightness = Math.random() * 0.5 + 0.5; } update() { this.y += 0.1; if (this.y > this.game.height) { this.y = 0; this.x = Math.random() * this.game.width; } } draw(ctx) { ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`; ctx.fillRect(this.x, this.y, this.size, this.size); } }
            class Particle { constructor(game, x, y, color, sizeMultiplier=1) { this.game = game; this.x = x; this.y = y; this.color = color; this.size = (Math.random() * 3 + 1) * sizeMultiplier; this.life = Math.random() * 500 + 200; this.vx = Math.random() * 4 - 2; this.vy = Math.random() * 4 - 2; this.markedForDeletion = false; } draw(ctx) { ctx.save(); if(settings.get('bloom')) { ctx.shadowBlur = 10; ctx.shadowColor = this.color; } ctx.globalAlpha = this.life / 500; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.restore(); } update(deltaTime) { this.x += this.vx; this.y += this.vy; this.life -= deltaTime; if(this.life <= 0) this.markedForDeletion = true; } }
            class AchievementNotifier { constructor(game, text) { this.game = game; this.text = text; this.width = 400; this.height = 50; this.x = game.width / 2 - this.width / 2; this.y = -this.height; this.targetY = 10; this.life = 4000; this.state = 'sliding_in'; } update(deltaTime) { this.life -= deltaTime; if(this.state === 'sliding_in') { this.y += (this.targetY - this.y) * 0.1; if(Math.abs(this.y - this.targetY) < 1) { this.y = this.targetY; this.state = 'waiting'; } } if(this.life <= 1000) { this.state = 'fading_out'; } if(this.life <= 0) this.markedForDeletion = true; } draw(ctx) { ctx.save(); if(this.state === 'fading_out') ctx.globalAlpha = this.life / 1000; ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.strokeStyle = 'gold'; ctx.lineWidth = 3; if (ctx.roundRect) { ctx.roundRect(this.x, this.y, this.width, this.height, [10]); ctx.fill(); ctx.stroke(); } else { ctx.fillRect(this.x, this.y, this.width, this.height); ctx.strokeRect(this.x, this.y, this.width, this.height); } ctx.fillStyle = 'gold'; ctx.font = "20px Cinzel"; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('üèÜ Achievement Unlocked!', this.x + this.width / 2, this.y + this.height * 0.35); ctx.fillStyle = 'white'; ctx.font = "16px VT323"; ctx.fillText(this.text, this.x + this.width / 2, this.y + this.height * 0.7); ctx.restore(); } }

            class Game {
                constructor(width, height, assetLoader) { this.width = width; this.height = height; this.assets = assetLoader; this.audio = new AudioManager(this.assets.sounds); this.player = new Player(this); this.platforms = this.createPlatforms(); this.enemies = []; this.projectiles = []; this.particles = []; this.healingOrbs = []; this.effects = []; this.damageNumbers = []; this.achievementNotifiers = []; this.stars = []; this.createStars(); this.gravity = 0.5; this.gameState = 'playing'; this.wave = 1; this.score = 0; this.lastTime = 0; this.enemyKeepAwayY = this.height * 0.1; this.cameraX = 0; this.cameraY = 0; this.cameraSmoothing = 0.05; this.rerollsUsedThisLevel = false; this.setupInput(); }
                createPlatforms() { return [ new Platform(0, this.height - 40, this.width, 40), new Platform(100, this.height - 120, 150, 20), new Platform(this.width - 250, this.height - 120, 150, 20), new Platform(this.width/2 - 100, this.height - 200, 200, 20), new Platform(this.width/2 - 350, this.height - 300, 150, 20), new Platform(this.width/2 + 200, this.height - 300, 150, 20)]; }
                createStars() { this.stars = []; for(let i=0; i < 200; i++) this.stars.push(new Star(this)); }
                setupInput() { window.addEventListener('keydown', e => { if(e.code === 'Space' && this.gameState === 'playing') this.player.jump(); }); }
                update(timestamp) { const deltaTime = timestamp - (this.lastTime || timestamp); this.lastTime = timestamp; this.score = Math.floor(timestamp / 1000 * 100); this.wave = 1 + Math.floor(this.player.level / 2); if (settings.get('cameraSmoothing')) this.updateCamera(); else { this.cameraX = 0; this.cameraY = 0; } this.stars.forEach(s => s.update()); this.player.update(inputHandler, deltaTime); const maxEnemies = 2 + Math.floor(this.player.level * 1.2); if (this.enemies.length < maxEnemies) { let spawnPool = ['basic', 'basic', 'basic']; if (this.player.level >= 4) spawnPool.push('eye', 'eye'); if (this.player.level >= 8) spawnPool.push('demon'); const enemyType = spawnPool[Math.floor(Math.random() * spawnPool.length)]; this.enemies.push(new Enemy(this, this.player.level, enemyType)); } this.enemies.forEach(e => e.update(this.player, this.enemies, deltaTime)); this.projectiles.forEach(p => p.update()); this.particles.forEach(p => p.update(deltaTime)); this.healingOrbs.forEach(o => o.update()); this.damageNumbers.forEach(dn => dn.update(deltaTime)); this.achievementNotifiers.forEach(an => an.update(deltaTime)); this.updateUpgrades(deltaTime); this.updateEffects(deltaTime); this.checkCollisions(); this.enemies = this.enemies.filter(e => !e.markedForDeletion); this.projectiles = this.projectiles.filter(p => !p.markedForDeletion); this.particles = this.particles.filter(p => !p.markedForDeletion); this.healingOrbs = this.healingOrbs.filter(o => !o.markedForDeletion); this.effects = this.effects.filter(e => !e.markedForDeletion); this.damageNumbers = this.damageNumbers.filter(dn => !dn.markedForDeletion); this.achievementNotifiers = this.achievementNotifiers.filter(an => !an.markedForDeletion); elements.hpText.textContent = `HP: ${Math.ceil(this.player.hp)}/${this.player.maxHp}`; elements.expText.textContent = `LVL: ${this.player.level}`; elements.hpBar.style.width = `${(this.player.hp / this.player.maxHp) * 100}%`; elements.expBar.style.width = `${(this.player.exp / this.player.expToNextLevel) * 100}%`; }
                updateCamera() { const targetX = this.player.x + this.player.width / 2 - this.width / 2; const targetY = this.player.y + this.player.height / 2 - this.height / 2; this.cameraX += (targetX - this.cameraX) * this.cameraSmoothing; this.cameraY += (targetY - this.cameraY) * this.cameraSmoothing; }
                draw(ctx) { ctx.save(); ctx.save(); ctx.translate(-this.cameraX * 0.2, -this.cameraY * 0.2); this.stars.forEach(s => { if(s.parallax > 0.3) s.draw(ctx) }); ctx.restore(); ctx.save(); ctx.translate(-this.cameraX * 0.4, -this.cameraY * 0.4); this.stars.forEach(s => { if(s.parallax <= 0.3) s.draw(ctx) }); ctx.restore(); ctx.translate(-this.cameraX, -this.cameraY); this.platforms.forEach(p => p.draw(ctx)); this.effects.forEach(e => e.draw(ctx)); this.healingOrbs.forEach(o => o.draw(ctx)); this.player.draw(ctx); this.enemies.forEach(e => e.draw(ctx)); this.projectiles.forEach(p => p.draw(ctx)); this.particles.forEach(p => p.draw(ctx)); this.damageNumbers.forEach(dn => dn.draw(ctx)); ctx.restore(); this.achievementNotifiers.forEach(an => an.draw(ctx)); }
                updateUpgrades(deltaTime) { if (this.player.upgrades.thunderbolt) { const tb = this.player.upgrades.thunderbolt; tb.timer -= deltaTime; if (tb.timer <= 0) { tb.timer = tb.interval; for (let i = 0; i < tb.count; i++) this.createThunderboltEffect(); } } if (this.player.upgrades.barrier) { const ba = this.player.upgrades.barrier; if(!ba.ready) { ba.timer -= deltaTime; if(ba.timer <= 0) { ba.ready = true; ba.timer = ba.cooldown; } } } if (this.player.upgrades.friction && this.player.distanceMoved > 100) { const count = this.player.upgrades.friction; for (let i = 0; i < count; i++) this.projectiles.push(new Projectile(this, this.player.x + this.player.width/2, this.player.y + this.player.height, -Math.PI / 2, this.player)); this.player.distanceMoved = 0; } }
                updateEffects(deltaTime) { this.effects.forEach(effect => effect.update(deltaTime)); }
                checkAchievements() { const unlocked = settings.get('unlockedAchievements'); for(const id in achievements) { if(!unlocked.includes(id) && achievements[id].check(this)) { unlocked.push(id); settings.set('unlockedAchievements', unlocked); this.achievementNotifiers.push(new AchievementNotifier(this, achievements[id].name)); } } }
                createThunderboltEffect() { const strikeX = this.cameraX + Math.random() * this.width; const damage = 50; const radius = 60; const warningTime = 1500; const strikeTime = 200; const effect = { x: strikeX, timer: warningTime, state: 'warning', markedForDeletion: false, update: (delta) => { effect.timer -= delta; if (effect.timer <= 0) { if (effect.state === 'warning') { effect.state = 'strike'; effect.timer = strikeTime; this.triggerScreenShake(); this.enemies.forEach(enemy => { const dist = Math.abs(enemy.x + enemy.width / 2 - strikeX); if (dist < radius) { enemy.takeDamage(damage, this.player); if (settings.get('showDamageNumbers')) this.damageNumbers.push(new DamageNumber(this, enemy.x + enemy.width / 2, enemy.y, damage, false)); } }); for(let i=0; i<50; i++) this.particles.push(new Particle(this, strikeX + (Math.random() - 0.5) * radius * 2, this.height - 40, 'yellow', 1.5)); } else { effect.markedForDeletion = true; } } }, draw: (ctx) => { if (effect.state === 'warning') { const alpha = 1 - (effect.timer / warningTime); ctx.fillStyle = `rgba(255, 255, 100, ${alpha * 0.3})`; ctx.beginPath(); ctx.ellipse(strikeX, this.height - 20, radius, radius/4, 0, 0, Math.PI * 2); ctx.fill(); } else if (effect.state === 'strike') { ctx.save(); ctx.strokeStyle = 'white'; ctx.lineWidth = 5; if(settings.get('bloom')) { ctx.shadowColor = 'yellow'; ctx.shadowBlur = 20; } ctx.beginPath(); ctx.moveTo(strikeX, 0); let currentX = strikeX; for (let y = 0; y < this.height; y += 20) { currentX += (Math.random() - 0.5) * 30; ctx.lineTo(currentX, y); } ctx.lineTo(currentX, this.height); ctx.stroke(); ctx.restore(); } } }; this.effects.push(effect); }
                checkCollisions() { this.projectiles.forEach(p => { if (p.owner instanceof Player) { this.enemies.forEach(e => { if(!e.markedForDeletion && this.rectCircleColliding({ x: e.x, y: e.y, width: e.width, height: e.height }, { x: p.x, y: p.y, r: p.radius })) { const isCrit = Math.random() < this.player.critChance; const damage = isCrit ? p.damage * this.player.critDamageModifier : p.damage; e.takeDamage(damage, p.owner); if (settings.get('showDamageNumbers')) this.damageNumbers.push(new DamageNumber(this, e.x + e.width / 2, e.y, damage, isCrit)); if(this.player.lifesteal > 0) this.player.hp = Math.min(this.player.maxHp, this.player.hp + this.player.lifesteal * damage); if(this.player.upgrades.wound) e.statusEffects.bleed = { damage: p.damage * 0.5, duration: 3000 }; if(this.player.upgrades.cold) { e.statusEffects.cold.amount = Math.min(0.8, (e.statusEffects.cold.amount || 0) + this.player.upgrades.cold); e.statusEffects.cold.duration = 2000; } p.markedForDeletion = true; }}); } else { if(this.rectCircleColliding({x: this.player.x, y: this.player.y, width: this.player.width, height: this.player.height}, {x: p.x, y: p.y, r: p.radius})) { this.player.takeDamage(p.damage); if (p.type === 'fireball') { this.player.applyBurn(); } p.markedForDeletion = true; } } }); if (this.player.upgrades.overheat) { const ohRadius = this.player.height / 2; this.enemies.forEach(e => { if(this.rectCircleColliding({ x: e.x, y: e.y, width: e.width, height: e.height }, { x: this.player.x + this.player.width / 2, y: this.player.y + this.player.height / 2, r: ohRadius })) e.takeDamage(this.player.upgrades.overheat.damage * (16.67 / 1000), this.player); }); } this.healingOrbs.forEach(orb => { if (this.rectCircleColliding({ x: this.player.x, y: this.player.y, width: this.player.width, height: this.player.height }, { x: orb.x, y: orb.y, r: orb.radius * 2 })) { this.player.hp = Math.min(this.player.maxHp, this.player.hp + 10); this.audio.play('cardPickup', 0.6); orb.markedForDeletion = true; } }); }
                rectCircleColliding(rect, circle) { let testX = circle.x, testY = circle.y; if (circle.x < rect.x) testX = rect.x; else if (circle.x > rect.x + rect.width) testX = rect.x + rect.width; if (circle.y < rect.y) testY = rect.y; else if (circle.y > rect.y + rect.height) testY = rect.y + rect.height; return Math.hypot(circle.x - testX, circle.y - testY) <= circle.r; }
                triggerScreenShake() { elements.gameContainer.classList.add('shake'); setTimeout(() => elements.gameContainer.classList.remove('shake'), 100); }
                togglePause() { if(elements.settingsScreen.classList.contains('hidden') && elements.achievementsScreen.classList.contains('hidden')) { this.gameState = this.gameState === 'playing' ? 'paused' : 'playing'; if (this.gameState === 'paused') { this.updatePauseScreenInfo(); this.audio.stopAllMusic(); } else { this.audio.startMusic('soundtrack'); } elements.pauseScreen.classList.toggle('hidden'); this.audio.play('click'); } }
                updatePauseScreenInfo() { const statsContainer = document.getElementById('pauseStats'); const upgradesContainer = document.getElementById('pauseUpgrades'); statsContainer.innerHTML = '<h3>Player Stats</h3>'; upgradesContainer.innerHTML = '<h3>Current Upgrades</h3>'; const p = this.player; statsContainer.innerHTML += `<p>HP: ${Math.ceil(p.hp)} / ${p.maxHp}</p><p>Defesa: ${(p.defense * 100).toFixed(0)}%</p><p>Velocidade: ${(p.speedModifier * 100).toFixed(0)}%</p><p>Dano Proj√©til: ${p.projectileDamage}</p><p>Velocidade Ataque: ${(p.attackSpeedModifier * 100).toFixed(0)}%</p><p>Chance Cr√≠tica: ${(p.critChance * 100).toFixed(0)}%</p><p>Dano Cr√≠tico: ${(p.critDamageModifier * 100).toFixed(0)}%</p><p>Roubo de Vida: ${(p.lifesteal * 100).toFixed(1)}%</p>`; if (p.collectedUpgrades.length === 0) { upgradesContainer.innerHTML += '<p>No upgrades collected yet.</p>'; } else { p.collectedUpgrades.forEach(upgradeId => { const upgradeInfo = upgrades[upgradeId]; if (upgradeInfo) { const upgradeEl = document.createElement('div'); upgradeEl.className = `upgrade-item ${upgradeInfo.rarity}`; upgradeEl.textContent = upgradeInfo.name; upgradesContainer.appendChild(upgradeEl); } }); } }
                gameOver() { this.gameState = 'gameOver'; settings.set('totalDeaths', settings.get('totalDeaths') + 1); this.checkAchievements(); this.audio.stopAllMusic(); this.audio.play('playerDeath'); elements.scoreText.textContent = `Score: ${this.score}`; if(this.score > settings.get('highScore')) { settings.set('highScore', this.score); elements.highScoreText.textContent = `NEW HIGH SCORE: ${this.score}`; } else { elements.highScoreText.textContent = `High Score: ${settings.get('highScore')}`; } elements.gameOverScreen.classList.remove('hidden'); }
                levelUp() { this.gameState = 'levelUp'; this.rerollsUsedThisLevel = false; this.showUpgradeCards(); }
                createExplosion(x, y, size) { for(let i=0; i < size/2; i++) { this.particles.push(new Particle(this, x, y, `hsl(${Math.random() * 60}, 100%, 50%)`)); }}
                showUpgradeCards() { const cardContainer = elements.levelUpScreen.querySelector('.card-container'); cardContainer.innerHTML = ''; elements.rerollButton.disabled = this.rerollsUsedThisLevel; elements.rerollButton.textContent = this.rerollsUsedThisLevel ? 'Reroll Used' : 'Reroll'; let pool = Object.keys(upgrades).filter(id => upgrades[id].rarity === 'common'); if(this.player.level >= 3) pool.push(...Object.keys(upgrades).filter(id => upgrades[id].rarity === 'uncommon')); if(this.player.level >= 7) pool.push(...Object.keys(upgrades).filter(id => upgrades[id].rarity === 'rare')); let choices = []; for(let i=0; i < this.player.upgradeChoices; i++) { if(pool.length === 0) break; let choiceIndex = Math.floor(Math.random() * pool.length); let choice = pool.splice(choiceIndex, 1)[0]; choices.push(choice); } choices.forEach(upgradeId => { const upgrade = upgrades[upgradeId]; const cardEl = document.createElement('div'); cardEl.className = `card ${upgrade.rarity}`; cardEl.dataset.upgradeId = upgradeId; let title = upgrade.name; cardEl.innerHTML = `<h3 class="card-title">${title}</h3><div class="card-icon">${upgrade.name.charAt(0)}</div><p class="card-description">${upgrade.description}</p>`; cardContainer.appendChild(cardEl); }); elements.levelUpScreen.classList.remove('hidden'); this.attachCardEvents(); }
                attachCardEvents() { const cards = elements.levelUpScreen.querySelectorAll('.card'); let isAnimating = false; const rerollHandler = () => { if(this.rerollsUsedThisLevel) return; this.rerollsUsedThisLevel = true; this.showUpgradeCards(); this.audio.play('click'); elements.rerollButton.removeEventListener('click', rerollHandler); }; elements.rerollButton.addEventListener('click', rerollHandler); cards.forEach((hoveredCard, hoveredIndex) => { hoveredCard.addEventListener('mouseenter', () => { if (isAnimating) return; cards.forEach((otherCard, otherIndex) => { if (hoveredIndex === otherIndex) otherCard.classList.add('hover-focus'); else if (otherIndex < hoveredIndex) otherCard.classList.add('look-right'); else otherCard.classList.add('look-left'); }); }); hoveredCard.addEventListener('mouseleave', () => { if (isAnimating) return; cards.forEach(card => card.classList.remove('hover-focus', 'look-left', 'look-right')); }); }); cards.forEach(clickedCard => { const clickHandler = () => { if (isAnimating) return; isAnimating = true; this.audio.play('cardPickup'); cards.forEach(c => c.classList.remove('hover-focus', 'look-left', 'look-right')); clickedCard.classList.add('selected'); cards.forEach(otherCard => { if (otherCard !== clickedCard) otherCard.classList.add('exploding'); }); this.player.applyUpgrade(clickedCard.dataset.upgradeId); setTimeout(() => { clickedCard.classList.add('exit-down'); setTimeout(() => { elements.levelUpScreen.classList.add('hidden'); cards.forEach(card => card.classList.remove('selected', 'exploding', 'exit-down')); this.gameState = 'playing'; this.lastTime = performance.now(); }, 1000); }, 1800); clickedCard.removeEventListener('click', clickHandler); elements.rerollButton.removeEventListener('click', rerollHandler); }; clickedCard.addEventListener('click', clickHandler); }); }
            }
        });
    </script>
</body>
</html>
